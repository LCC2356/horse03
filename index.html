<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>HORSE RUNRUN - TEAM MODE</title>
  <script src="https://cdn.bootcdn.net/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg: #111;
      --primary: #ffffff;
      --panel: #222222;
      --border: #444444;
      --game-w: 3400px;
      --game-h: 100px;
      --accent: #40e0d0;
    }

    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }

    body {
      margin: 0; padding: 0;
      background-color: #0a0a0a;
      font-family: 'VT323', monospace;
      color: var(--primary);
      height: 100vh; width: 100vw;
      overflow: hidden;
      display: flex; flex-direction: column;
      position: relative;
    }

    .hidden { display: none !important; }

    #desktop-view {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
    }

    #game-container {
      position: absolute;
      left: 50%; top: 50%;
      width: 0; height: 0;
      display: flex; justify-content: center; align-items: center;
    }

    #game-screen {
      width: var(--game-w); height: var(--game-h);
      background: #000; position: relative;
      border: 2px solid var(--primary);
      border-right: none;
      box-shadow: none;
      overflow: hidden;
      flex-shrink: 0;
      transition: background-color 0.1s;
    }

    /* === 红绿灯模式背景样式 === */
    .bg-green { background: #002200 !important; box-shadow: inset 0 0 50px #00ff00 !important; border-color: #00ff00 !important; }
    .bg-yellow { background: #332200 !important; box-shadow: inset 0 0 50px #ffb300 !important; border-color: #ffb300 !important; }
    .bg-red { background: #440000 !important; box-shadow: inset 0 0 100px #ff0000 !important; border-color: #ff0000 !important; }

    /* === 拔河模式专用视觉层 === */
    #tug-layer {
      position: absolute; inset: 0; z-index: 1; display: none;
    }
    /* 蓝色区域（左侧）- 升级为强发光风格 */
    #tug-blue-zone {
      position: absolute; left: 0; top: 0; bottom: 0;
      width: 50%;
      background: #001133;
      box-shadow: inset 0 0 80px #2979ff;
      border-right: 6px solid #fff;
      filter: drop-shadow(0 0 10px #fff);
      transition: width 0.1s linear;
      z-index: 2;
    }
    /* 红色区域（右侧）- 升级为强发光风格 */
    #tug-red-zone {
      position: absolute; right: 0; top: 0; bottom: 0;
      width: 50%;
      background: #330000;
      box-shadow: inset 0 0 80px #ff0000;
      z-index: 1;
      transition: width 0.1s linear;
    }

    .icon-vs {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 60px; color: #fff; text-shadow: 0 0 20px #fff, 0 0 40px #ff00ff; z-index: 10;
      opacity: 1; pointer-events: none; mix-blend-mode: overlay;
    }

    #track-wrapper {
      display: flex;
      width: calc(var(--game-w) + var(--game-h));
      height: var(--game-h);
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      flex-shrink: 0;
      position: relative;
    }

    #side-qr-box {
      width: var(--game-h);
      height: var(--game-h);
      background: #000;
      border: 2px solid var(--primary);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      flex-shrink: 0;
    }

    .join-label {
      position: absolute;
      bottom: 2px;
      left: 0; width: 100%;
      text-align: center;
      font-size: 14px;
      color: #888;
      pointer-events: none;
      text-shadow: 1px 1px 0 #000;
    }

    .flash-active { animation: track-flash 0.2s ease-out; }
    @keyframes track-flash {
      0% { background-color: rgba(255, 255, 255, 0.4); box-shadow: inset 0 0 150px var(--primary); border-color: #fff; }
      100% { background-color: #000; box-shadow: none; border-color: var(--primary); }
    }

    .grid-bg {
      position: absolute; inset: 0; opacity: 0.2;
      background-image: linear-gradient(rgba(255, 255, 255, 0.3) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255, 255, 255, 0.3) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
    }
    .finish-line {
      position: absolute; top: 0; bottom: 0; right: 400px; width: 12px;
      background-image: linear-gradient(45deg, #fff 25%, transparent 25%, transparent 50%, #fff 50%, #fff 75%, transparent 75%, transparent);
      background-size: 12px 12px; opacity: 0.8; z-index: 0;
    }

    /* HUD */
    .hud { position: absolute; bottom: 4px; right: 10px; font-size: 32px; opacity: 0.5; letter-spacing: 2px; z-index: 110; }

    #track-display-bar {
      position: absolute;
      top: 50%; transform: translateY(-50%);
      left: 0; width: 100%; height: 100px;
      display: none;
      align-items: center; justify-content: center;
      z-index: 100;
      pointer-events: none;
    }

    .bar-container {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bar-text-item {
      font-size: 80px;
      letter-spacing: 2px;
      text-shadow: 0 0 20px currentColor;
      font-weight: bold;
      width: 260px;
      display: flex;
      justify-content: center;
      flex-shrink: 0;
      margin: 0;
      animation: text-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    @keyframes text-pop {
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1.0); opacity: 1; }
    }

    @keyframes text-vanish {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    .queue-alert {
      position: absolute; top: 10px; right: 20px;
      font-size: 24px; color: #ffb300; text-shadow: 0 0 5px #ffb300;
      display: none; z-index: 20;
    }

    #vfd-overlay {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: flex-start;
      overflow: hidden;
      opacity: 0;
      pointer-events: none; z-index: 95;
      padding-left: 0;
    }

    #vfd-overlay i {
      display: inline-block;
      width: 0; height: 0;
      border-top: 15px solid transparent;
      border-bottom: 15px solid transparent;
      border-left: 80px solid var(--primary);
      margin-right: 20px;
      flex-shrink: 0;
      opacity: 0;
      transform: scale(0.8) skewX(-20deg);
      filter: drop-shadow(0 0 5px var(--primary));
    }

    .vfd-active { opacity: 1 !important; }
    .vfd-active i { animation: vfd-flash 0.4s ease-out forwards calc(var(--d) * 1s); }

    @keyframes vfd-flash {
      0% { opacity: 0; transform: scale(0.8) translateX(0); }
      10% { opacity: 1; transform: scale(1.2) translateX(10px); filter: drop-shadow(0 0 15px var(--primary)) drop-shadow(0 0 30px #fff); }
      40% { opacity: 0.3; transform: scale(1.0) translateX(20px); }
      100% { opacity: 0; transform: scale(0.8) translateX(30px); }
    }

    .entity { position: absolute; width: 44px; height: 44px; will-change: transform; }
    .pixel-grid {
      display: grid;
      grid-template-columns: repeat(11, 1fr);
      width: 100%; height: 100%;
      transform-origin: bottom center;
      transition: transform 0.2s;
    }

    .crown-container {
      position: absolute; top: -31px; left: 50%; transform: translateX(-50%);
      width: 18px; height: 18px;
      animation: bounce 1s infinite; z-index: 10;
      display: flex; flex-direction: column-reverse; align-items: center;
    }
    .aura {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 160%; height: 160%; border-radius: 50%;
      background: radial-gradient(circle, rgba(250,204,21,0.4) 0%, transparent 70%);
      box-shadow: 0 0 10px #facc15; z-index: -1;
      animation: pulse 0.5s infinite alternate; display: none;
    }
    @keyframes pulse { from { opacity: 0.5; transform: translate(-50%, -50%) scale(1); } to { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } }

    .name-tag {
      position: absolute; top: -18px; left: 50%; transform: translateX(-50%);
      font-size: 20px; white-space: nowrap; color: #40e0d0; text-shadow: 1px 1px 0 #000;
    }
    .grass { position: absolute; width: 6px; height: 6px; background: #69f0ae; box-shadow: 0 0 4px #69f0ae; }

    .obstacle {
      position: absolute;
      width: 10px; height: 30px;
      background: #ffffff;
      border: 2px solid #ffffff;
      box-shadow: 0 0 15px #ffffff;
      z-index: 5;
      bottom: 5px;
    }

    /* 拔河对撞粒子 */
    .tug-spark {
      position: absolute; width: 4px; height: 4px; background: #fff;
      box-shadow: 0 0 10px #fff, 0 0 20px #ff00ff;
      pointer-events: none; z-index: 20;
      border-radius: 50%;
    }

    /* 拔河点击震荡波 */
    .shockwave {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 10px; height: 10px; border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.8);
      pointer-events: none; z-index: 5;
      animation: shock-expand 0.4s ease-out forwards;
    }
    @keyframes shock-expand {
      0% { width: 10px; height: 10px; opacity: 1; border-width: 4px; }
      100% { width: 100px; height: 100px; opacity: 0; border-width: 0px; }
    }

    .explosion { position: absolute; width: 6px; height: 6px; background: #ff5252; pointer-events: none; }
    @keyframes bounce { 0%, 100% { transform: translate(-50%, 0); } 50% { transform: translate(-50%, -4px); } }

    #layer-snow { position: absolute; inset: 0; pointer-events: none; z-index: 1; }
    .snowflake {
      position: absolute; top: -10px;
      background: #ffffff; border-radius: 50%; box-shadow: 0 0 4px #ffffff;
      animation-name: snowfall; animation-timing-function: linear; animation-fill-mode: forwards;
    }
    @keyframes snowfall { to { transform: translateY(calc(var(--game-h) + 20px)); } }

    .trail-segment {
      position: absolute; height: 4px; width: 50px; border-radius: 0px;
      pointer-events: none; opacity: 0.8;
      animation: trail-fade 0.4s ease-out forwards;
      z-index: 90; mix-blend-mode: screen;
    }
    @keyframes trail-fade { to { opacity: 0; transform: translateX(-40px) scaleX(0.5); } }

    .trail-active .p-grid {
      filter: drop-shadow(-10px 0 5px var(--trail-c)) drop-shadow(-20px 0 10px var(--trail-c)) opacity(0.95);
      transform: scaleX(1.3) skewX(-15deg);
      transition: filter 0.1s ease-out, transform 0.1s ease-out;
    }

    .pixel-emoji-container {
      position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
      pointer-events: none; z-index: 200;
      animation: pixel-float-smooth 2.5s linear forwards;
    }

    .pop-text {
      position: absolute; top: -24px; left: 50%; transform: translateX(-50%);
      color: var(--accent); font-size: 28px; letter-spacing: 2px;
      text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
      white-space: nowrap; pointer-events: none; z-index: 210;
      font-family: 'VT323', monospace;
      animation: pixel-float-smooth 2.5s linear forwards;
    }

    .pixel-icon-base { background: transparent; position: relative; }

    @keyframes pixel-float-smooth {
      0% { opacity: 0; transform: translate(-50%, 10px) scale(0.5); }
      10% { opacity: 1; transform: translate(-50%, -10px) scale(1); }
      25% { transform: translate(calc(-50% + 20px), -40px) scale(1); }
      50% { transform: translate(calc(-50% - 20px), -80px) scale(1); }
      75% { transform: translate(calc(-50% + 15px), -120px) scale(1); opacity: 0.8; }
      100% { transform: translate(-50%, -160px) scale(1); opacity: 0; }
    }

    .emoji-bar {
      display: none !important; /* 隐藏表情栏 */
      gap: 15px; margin-top: 40px; pointer-events: auto; z-index: 22001; justify-content: center;
    }
    .emoji-btn {
      background: #222; border: 2px solid #555; color: #fff;
      width: 60px; height: 60px; border-radius: 12px; cursor: pointer;
      display: flex; justify-content: center; align-items: center;
      transition: transform 0.1s; -webkit-tap-highlight-color: transparent;
      overflow: hidden; font-family: 'VT323', monospace;
    }
    .emoji-btn:active { transform: scale(0.8); background: #fff; border-color: #fff; color: #000; }
    .emoji-btn:active .pixel-icon-base { filter: invert(1); }

    #bottom-controls {
      position: fixed; bottom: 20px; left: 20px;
      display: flex; align-items: center; gap: 15px;
      padding: 15px; background: rgba(0, 0, 0, 0.85);
      border: 1px solid var(--border); border-radius: 8px; z-index: 1000;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }
    #qrcode {
      background: white; padding: 3px; width: 90px; height: 90px;
      display: flex; justify-content: center; align-items: center; border-radius: 2px;
    }
    #qrcode img { display: block; width: 100%; height: 100%; }

    .control-group {
      display: flex; flex-direction: column; gap: 5px; border-left: 1px solid #333; padding-left: 15px; width: 140px;
    }
    .control-label { font-size: 0.8rem; color: #888; letter-spacing: 1px; }
    .input-wrapper { display: flex; align-items: center; gap: 8px; width: 100%; }

    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 5px 0; }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #333; border-radius: 3px; border: 1px solid #555; }
    input[type=range]::-webkit-slider-thumb { height: 16px; width: 16px; border-radius: 2px; background: var(--accent); cursor: pointer; -webkit-appearance: none; margin-top: -6px; box-shadow: 0 0 5px var(--accent); }

    /* ✅ 允许小数：zoom-input step 改为 0.1；y-input也允许小数 */
    input[type="number"] {
      background: #222; border: 1px solid var(--border); color: var(--primary);
      font-family: 'VT323', monospace; font-size: 1.4rem; width: 70px;
      text-align: center; padding: 2px; border-radius: 4px;
    }
    .unit-label { font-size: 1.2rem; color: #555; }

    input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--accent); }

    select {
      background: #222; border: 2px solid var(--border); color: white;
      padding: 8px; font-family: 'VT323', monospace; font-size: 1.2rem;
      margin-right: 10px; cursor: pointer;
    }

    .btn {
      background: #222; border: 2px solid var(--primary); color: var(--primary);
      padding: 10px 20px; font-family: 'VT323', monospace; font-size: 1.2rem;
      cursor: pointer; text-transform: uppercase; box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      transition: all 0.2s; margin-left: 5px;
    }
    .btn:hover { background: var(--primary); color: #000; }
    .btn:active { transform: translateY(2px); }

    #modal-editor {
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 9000;
      display: none; justify-content: center; align-items: center;
    }
    .modal-content {
      background: #1a1c20; border: 2px solid var(--primary); padding: 30px;
      display: flex; flex-direction: column; align-items: center; gap: 20px;
    }
    .editor-grid {
      display: grid; grid-template-columns: repeat(11, 1fr); grid-template-rows: repeat(11, 1fr);
      gap: 2px; background: #333; border: 2px solid #555; touch-action: none;
    }
    .editor-cell { width: 28px; height: 28px; background: #000; }
    .color-picker { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
    .c-dot { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #333; }
    .c-dot.active { border-color: white; transform: scale(1.1); }
    .btn-outline { background: transparent; border-color: #ff5252; color: #ff5252; }
    .btn-flex { flex: 1; display: flex; justify-content: center; align-items: center; }

    #mobile-view {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #111; display: flex; flex-direction: column; z-index: 20000;
      padding: 20px; align-items: center;
    }
    .m-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; padding-bottom: 15px; margin-bottom: 20px; flex-shrink: 0; width: 100%; max-width: 400px; }
    .m-title { font-size: 1.5rem; color: #fff; }
    .m-status { background: #222; padding: 4px 8px; border-radius: 4px; font-size: 1rem; color: #fff; border: 1px solid #444; }
    .m-controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 15px; flex-shrink: 0; width: 100%; max-width: 400px; }
    input[type="text"] {
      background: #222; border: 1px solid #444; color: white; padding: 12px;
      font-family: inherit; text-align: center; font-size: 1.5rem; width: 100%; border-radius: 4px;
    }
    .m-canvas-container {
      flex: 1; display: flex; justify-content: center; align-items: center;
      background: #1a1a1a; border-radius: 8px; margin-bottom: 20px;
      overflow: hidden; width: 100%; max-width: 400px;
    }
    .m-footer { display: flex; gap: 15px; height: 60px; flex-shrink: 0; width: 100%; max-width: 400px; }

    #m-controller {
      position: fixed; inset: 0; background: #111; z-index: 22000;
      display: none; flex-direction: column; align-items: center; justify-content: center;
    }

    /* 手机端选择框容器 */
    #m-mode-wrapper {
      margin-bottom: 20px; width: 100%; max-width: 300px; display: none; justify-content: center;
    }
    #m-mode-select {
      background: #222; border: 2px solid #555; color: #fff; padding: 10px;
      font-family: 'VT323'; font-size: 1.8rem; width: 100%; text-align: center;
      border-radius: 8px;
    }

    .push-btn {
      width: 250px; height: 250px;
      border-radius: 50%;
      background: #222; border: 8px solid #444;
      color: #888; font-size: 4rem; font-family: 'VT323', monospace;
      display: flex; justify-content: center; align-items: center;
      box-shadow: 0 0 50px rgba(0,0,0, 0.4);
      transition: all 0.1s; user-select: none;
      cursor: pointer; -webkit-tap-highlight-color: transparent;
      touch-action: none;
      text-align: center; line-height: 1; padding: 20px;
    }
    .push-btn:active { transform: scale(0.95); }
    .controller-info { font-size: 1.5rem; color: #888; margin-bottom: 30px; text-align: center; }
    .btn-wait { background: #1a1a1a !important; border-color: #333 !important; color: #555 !important; }
    .btn-mash { background: #fff !important; border-color: #ccc !important; color: #000 !important; box-shadow: 0 0 60px rgba(255, 255, 255, 0.6) !important; }
    .btn-start { background: #ffffff !important; border: 8px solid #ccc !important; color: #000000 !important; box-shadow: 0 0 60px rgba(255, 255, 255, 0.6) !important; }
    .btn-dead { background: #ffffff !important; border: 8px solid #000000 !important; color: #000000 !important; box-shadow: 0 0 30px rgba(255, 255, 255, 0.5) !important; font-size: 3rem !important; }

    /* 手机端队伍按钮颜色 - 强制覆盖，置于底部以确保优先级 */
    .btn-team-red {
      background: #ff0000 !important;
      border-color: #ff5252 !important;
      color: #fff !important;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.6) !important;
      text-shadow: 0 0 10px #fff !important;
    }
    .btn-team-blue {
      background: #0044ff !important;
      border-color: #40e0d0 !important;
      color: #fff !important;
      box-shadow: 0 0 30px rgba(0, 100, 255, 0.6) !important;
      text-shadow: 0 0 10px #fff !important;
    }

    /* ✅ 手机端隐藏控制面板 */
    #m-admin {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.92);
      z-index: 25000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .m-admin-card{
      width: 100%;
      max-width: 420px;
      background: #141414;
      border: 2px solid #fff;
      border-radius: 10px;
      padding: 18px;
      box-shadow: 0 0 40px rgba(255,255,255,0.12);
    }
    .m-admin-title{
      font-size: 1.8rem;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .m-admin-hint{
      font-size: 1rem;
      color: #888;
      margin-bottom: 14px;
    }
    .m-admin-row{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 0;
      border-top: 1px solid #2b2b2b;
    }
    .m-admin-row:first-of-type{ border-top: none; }
    .m-admin-label{
      font-size: 1.2rem;
      color: #ddd;
      letter-spacing: 0.5px;
      min-width: 90px;
    }
    .m-admin-control{
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      justify-content: flex-end;
    }
    .m-admin-control input[type="number"]{
      width: 120px;
      font-size: 1.4rem;
      padding: 6px 8px;
      border-radius: 6px;
    }
    .m-admin-control select{
      width: 200px;
      font-size: 1.3rem;
      margin-right: 0;
      border-radius: 6px;
    }
    .m-admin-actions{
      display: flex;
      gap: 12px;
      margin-top: 14px;
    }
    .m-btn-small{
      flex: 1;
      padding: 12px 10px;
      font-size: 1.2rem;
      border-radius: 8px;
      border: 2px solid #fff;
      background: #222;
      color: #fff;
      font-family: 'VT323', monospace;
      text-transform: uppercase;
    }
    .m-btn-small:active{ transform: scale(0.98); }
    .m-btn-small.primary{ background: #fff; color:#000; }
    .m-btn-small.danger{ border-color:#ff5252; color:#ff5252; }
  </style>
</head>

<body>
  <div id="desktop-view">
    <div id="game-container">
      <div id="track-wrapper">
        <div id="game-screen">
          <div class="grid-bg"></div>

          <div id="tug-layer">
            <div id="tug-red-zone"></div>
            <div id="tug-blue-zone">
              <span class="tug-icon" style="right: 10px; color: #fff;">&#9664;</span>
            </div>
            <div class="icon-vs">VS</div>
          </div>

          <div class="finish-line"></div>

          <div id="hud" class="hud">NOWHERE TO RUN</div>

          <div id="track-display-bar">
            <div class="bar-container" id="bar-text"></div>
          </div>

          <div id="queue-text" class="queue-alert"></div>
          <div id="vfd-overlay"></div>
          <div id="layer-snow"></div>
          <div id="layer-grass"></div>
          <div id="layer-pony"></div>
          <div id="layer-fx"></div>
        </div>

        <div id="side-qr-box">
          <div id="qrcode"></div>
          <div class="join-label">JOIN</div>
        </div>
      </div>
    </div>

    <div id="bottom-controls">
      <div class="control-group" style="border-left: none;">
        <span class="control-label">ZOOM</span>
        <!-- ✅ 允许小数：step=0.1 -->
        <input type="range" id="zoom-slider" min="1" max="500" step="0.1" value="100" />
        <div class="input-wrapper">
          <input type="number" id="zoom-input" value="100" min="1" max="500" step="0.1" />
          <span class="unit-label">%</span>
        </div>
      </div>

      <div class="control-group">
        <span class="control-label">Y OFFSET</span>
        <input type="range" id="y-slider" min="-1200" max="1200" step="1" value="0" />
        <div class="input-wrapper">
          <input type="number" id="y-input" value="0" step="0.1" />
          <span class="unit-label">PX</span>
        </div>
      </div>

      <div class="control-group">
        <span class="control-label">GAME MODE</span>
        <select id="mode-select">
          <option value="RANDOM">RANDOM</option>
          <option value="CLASSIC">RUN</option>
          <option value="HURDLE">JUMP</option>
          <option value="RED_LIGHT">STOP?</option>
          <option value="TUG">TEAM</option>
        </select>
      </div>

      <!-- ✅ 桌面端下雪开关 -->
      <div class="control-group">
        <span class="control-label">SNOW</span>
        <div class="input-wrapper">
          <input type="checkbox" id="snow-toggle" checked />
          <span class="unit-label" id="snow-toggle-label">ON</span>
        </div>
      </div>

      <button class="btn" onclick="spawnTestPony()">+ BOT</button>
      <button class="btn" onclick="openDesktopEditor()">+ PONY</button>
    </div>
  </div>

  <div id="modal-editor" class="hidden">
    <div class="modal-content">
      <h2 class="vfd-glow" style="margin: 0;">DESIGN RUNNER</h2>
      <input
        type="text"
        id="pc-name"
        placeholder="ENTER NAME"
        maxlength="8"
        value="PLAYER"
        style="background:#222; border:1px solid #444; color:white; padding:10px; text-align:center; font-size:1.5rem; border-radius:4px;"
      />
      <div class="color-picker" id="pc-colors"></div>
      <div id="pc-grid" class="editor-grid"></div>
      <div style="display: flex; gap: 20px; width: 100%;">
        <button class="btn btn-outline btn-flex" onclick="document.getElementById('modal-editor').style.display='none'">CANCEL</button>
        <button class="btn btn-outline btn-flex" style="border-color:#ffb300; color:#ffb300;" onclick="clearDesktop()">CLEAR</button>
        <button class="btn btn-flex" onclick="savePCPony()">SPAWN</button>
      </div>
    </div>
  </div>

  <div id="mobile-view" style="display: none;">
    <div id="m-editor-ui">
      <div class="m-header">
        <span class="m-title" id="m-title">NOWHERE TO RUN</span>
        <span id="m-status" class="m-status">Wait...</span>
      </div>
      <div class="m-controls">
        <input type="text" id="m-name" placeholder="ENTER NAME" maxlength="8" />
        <div class="color-picker" id="m-colors"></div>
      </div>
      <div class="m-canvas-container">
        <div id="m-grid" class="editor-grid"></div>
      </div>
      <div class="m-footer">
        <button class="btn btn-outline btn-flex" onclick="clearMobile()">CLEAR CANVAS</button>
        <button class="btn btn-flex" onclick="sendMobile()">RUN</button>
      </div>
    </div>

    <!-- ✅ 手机端隐藏控制面板（五次点击标题进入） -->
    <div id="m-admin">
      <div class="m-admin-card">
        <div class="m-admin-title">
          <span>HOST CONTROL</span>
          <span style="font-size:1rem; color:#888;">(hidden)</span>
        </div>
        <div class="m-admin-hint">Zoom / Y Offset supports decimals. Game Mode & Snow apply to host instantly.</div>

        <div class="m-admin-row">
          <div class="m-admin-label">ZOOM</div>
          <div class="m-admin-control">
            <input type="number" id="m-admin-zoom" min="1" max="500" step="0.1" value="100" />
            <span class="unit-label">%</span>
          </div>
        </div>

        <div class="m-admin-row">
          <div class="m-admin-label">Y OFFSET</div>
          <div class="m-admin-control">
            <input type="number" id="m-admin-y" min="-1200" max="1200" step="0.1" value="0" />
            <span class="unit-label">PX</span>
          </div>
        </div>

        <div class="m-admin-row">
          <div class="m-admin-label">MODE</div>
          <div class="m-admin-control">
            <select id="m-admin-mode">
              <option value="RANDOM">RANDOM</option>
              <option value="CLASSIC">RUN</option>
              <option value="HURDLE">JUMP</option>
              <option value="RED_LIGHT">STOP?</option>
              <option value="TUG">TEAM</option>
            </select>
          </div>
        </div>

        <div class="m-admin-row">
          <div class="m-admin-label">SNOW</div>
          <div class="m-admin-control" style="justify-content:flex-end;">
            <input type="checkbox" id="m-admin-snow" checked />
            <span class="unit-label" id="m-admin-snow-label">ON</span>
          </div>
        </div>

        <div class="m-admin-actions">
          <button class="m-btn-small primary" id="m-admin-apply">APPLY</button>
          <button class="m-btn-small" id="m-admin-addbot">+ BOT</button>
          <button class="m-btn-small danger" id="m-admin-back">BACK</button>
        </div>
      </div>
    </div>

    <div id="m-controller">
      <div id="m-info" class="controller-info">GET READY</div>

      <div id="m-mode-wrapper">
        <select id="m-mode-select">
          <option value="RANDOM">RANDOM</option>
          <option value="CLASSIC">RUN</option>
          <option value="HURDLE">JUMP</option>
          <option value="RED_LIGHT">STOP?</option>
          <option value="TUG">TEAM</option>
        </select>
      </div>

      <div id="m-btn" class="push-btn btn-wait">WAIT</div>

      <div class="emoji-bar">
        <div class="emoji-btn" onclick="sendEmoji('HEART')" data-icon="HEART"></div>
        <div class="emoji-btn" onclick="sendEmoji('POOP')" data-icon="POOP"></div>
        <div class="emoji-btn" onclick="sendEmoji('BOLT')" data-icon="BOLT"></div>
        <div class="emoji-btn" onclick="sendEmoji('FACE')" style="font-size: 2rem;">?</div>
      </div>
    </div>
  </div>

  <script>
    const GAME_W = 3400;
    const GAME_H = 100;
    const PONY_SIZE = 50;
    const FINISH_X = GAME_W - 400;

    const COLORS = { CYAN:'#40e0d0', YELLOW:'#ffb300', RED:'#ff5252', GREEN:'#69f0ae', PURPLE:'#e040fb', WHITE:'#ffffff', BLUE:'#2979ff' };

    const DEFAULT_PIXELS = [
      [0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0], [0,0,0,0,0,0,0,1,1,1,1], [0,1,0,0,0,0,1,1,1,0,0],
      [1,0,1,1,1,1,1,1,1,0,0], [1,0,1,1,1,1,1,1,1,0,0], [0,0,1,1,1,1,1,1,1,0,0], [0,0,1,0,1,0,1,0,1,0,0], [0,0,1,0,1,0,1,0,1,0,0], [0,0,1,0,1,0,1,0,1,0,0]
    ];

    const PIXEL_ART_MAPS = {
      'HEART': [ [0,1,1,0,1,1,0], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [0,1,1,1,1,1,0], [0,0,1,1,1,0,0], [0,0,0,1,0,0,0] ],
      'POOP': [ [0,0,0,1,0,0,0], [0,0,1,1,1,0,0], [0,1,1,1,1,1,0], [1,0,1,1,1,0,1], [1,1,1,1,1,1,1] ],
      'BOLT': [ [0,0,1,1,1,0], [0,1,1,1,0,0], [1,1,1,1,1,0], [0,0,0,1,1,0], [0,0,1,1,0,0], [0,0,1,0,0,0] ]
    };

    const SONGS = {
      'JINGLE': [ 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 392.0, 261.6, 293.7, 329.6, 349.2, 349.2, 349.2, 349.2, 349.2, 329.6, 329.6, 329.6, 293.7, 293.7, 329.6, 293.7, 392.0 ],
      'MERRY': [ 261.6, 349.2, 349.2, 392.0, 349.2, 329.6, 293.7, 293.7, 293.7, 392.0, 392.0, 440.0, 392.0, 349.2, 329.6, 261.6, 261.6, 440.0, 440.0, 466.2, 440.0, 392.0, 349.2, 293.7, 261.6, 261.6, 293.7, 392.0, 329.6, 349.2 ],
      'DECK': [ 523.3, 493.9, 440.0, 392.0, 349.2, 329.6, 293.7, 261.6, 293.7, 329.6, 349.2, 293.7, 329.6, 293.7, 261.6 ]
    };

    const SOUND_STYLES = {
      'GAMEBOY': { type: 'square', decay: 0.1, attack: 0.01 },
      'FLUTE': { type: 'sine', decay: 0.3, attack: 0.05 },
      'LASER': { type: 'sawtooth', decay: 0.15, attack: 0.01 },
      'CRYSTAL': { type: 'triangle', decay: 0.5, attack: 0.01 },
      'TUBA': { type: 'square', decay: 0.2, attack: 0.1 },
      'PIANO': { type: 'triangle', decay: 0.3, attack: 0.001 },
      'BANJO': { type: 'sawtooth', decay: 0.1, attack: 0.001 }
    };
    const STYLE_KEYS = Object.keys(SOUND_STYLES);

    let noteIndex = 0;
    let myCurrentSongKey = 'JINGLE';
    let myStyleKey = 'GAMEBOY';

    let ponies = [];
    let ponyQueue = [];
    let grass = [];
    let obstacles = [];
    let gameState = 'ROAMING';
    let cooldownTimer = 0;
    let waitTimer = 0;

    let currentGameMode = 'CLASSIC';
    let redLightTimer = 0;
    let lightState = 'GREEN';

    // === 拔河变量 ===
    let tugValue = 50;

    let peer = null, conn = null;
    let pcGrid = JSON.parse(JSON.stringify(DEFAULT_PIXELS));
    let mobileGrid = JSON.parse(JSON.stringify(DEFAULT_PIXELS));
    let selectedColor = COLORS.CYAN;
    let playerUUID = null;

    let mobileBtnState = 'wait';
    let audioCtx = null;
    let lastTapTime = 0;

    let layout = { scale: 1.0, x: 0, y: 0 };
    let currentBarText = '';
    let lastBroadcastText = '';

    let lastShakeTime = 0; // 摇一摇防抖

    // ✅ 需求：关闭“上滑跳跃”（仍保留抬手机跳）
    let swipeJumpEnabled = false;

    // ✅ 桌面端/网页端下雪开关（可被手机端控制）
    let snowEnabled = true;

    // ✅ 手机端隐藏控制面板：标题五连击
    let mTitleTapCount = 0;
    let mTitleTapTimer = null;

    const PEER_CONFIG = {
      debug: 2,
      config: {
        'iceServers': [
          { url: 'stun:stun.l.google.com:19302' },
          { url: 'stun:stun1.l.google.com:19302' }
        ]
      }
    };

    /* ==================== FUNCTIONS ==================== */

    function vibrate(pattern) {
      if (navigator.vibrate) navigator.vibrate(pattern);
    }

    function createPixelIcon(type, pixelSize = 2, color = '#fff') {
      const container = document.createElement('div');
      container.className = 'pixel-icon-base';
      container.style.width = pixelSize + 'px';
      container.style.height = pixelSize + 'px';
      const map = PIXEL_ART_MAPS[type] || PIXEL_ART_MAPS['HEART'];
      let boxShadow = '';
      for(let y=0; y<map.length; y++) {
        for(let x=0; x<map[y].length; x++) {
          if (map[y][x] === 1) { boxShadow += `${x*pixelSize}px ${y*pixelSize}px ${color},`; }
        }
      }
      container.style.boxShadow = boxShadow.slice(0, -1);
      const widthOffset = (7 * pixelSize) / 2;
      container.style.transform = `translateX(-${widthOffset}px)`;
      return container;
    }

    function playSignalSound(type) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const now = audioCtx.currentTime;

      gain.connect(audioCtx.destination);
      osc.connect(gain);

      if (type === 'GREEN') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
      } else if (type === 'YELLOW') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);

        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        gain2.connect(audioCtx.destination);
        osc2.connect(gain2);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(400, now + 0.15);
        gain2.gain.setValueAtTime(0.2, now + 0.15);
        gain2.gain.linearRampToValueAtTime(0, now + 0.25);
        osc2.start(now + 0.15); osc2.stop(now + 0.25);
      } else if (type === 'RED') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.5);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
      }
    }

    function playNextNote() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const songArr = SONGS[myCurrentSongKey] || SONGS['JINGLE'];
      let freq = songArr[noteIndex % songArr.length];
      while (freq === 0) {
        noteIndex++;
        freq = songArr[noteIndex % songArr.length];
      }
      noteIndex++;
      const style = SOUND_STYLES[myStyleKey] || SOUND_STYLES['GAMEBOY'];
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = style.type;
      osc.frequency.setValueAtTime(freq, now);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.3, now + style.attack);
      gain.gain.exponentialRampToValueAtTime(0.01, now + style.attack + style.decay);
      osc.connect(gain);
      osc.start(now);
      osc.stop(now + style.attack + style.decay + 0.1);
    }

    function randomizeMusic() {
      const songKeys = Object.keys(SONGS);
      myCurrentSongKey = songKeys[Math.floor(Math.random() * songKeys.length)];
      myStyleKey = STYLE_KEYS[Math.floor(Math.random() * STYLE_KEYS.length)];
      noteIndex = 0;
    }

    // ✅ 桌面端：同步雪开关UI
    function syncDesktopSnowUI() {
      const snowToggle = document.getElementById('snow-toggle');
      const snowLabel = document.getElementById('snow-toggle-label');
      if (snowToggle) snowToggle.checked = !!snowEnabled;
      if (snowLabel) snowLabel.textContent = snowEnabled ? 'ON' : 'OFF';
      if (!snowEnabled) {
        const snowLayer = document.getElementById('layer-snow');
        if (snowLayer) snowLayer.innerHTML = '';
      }
    }

    // ✅ 手机端：打开/关闭隐藏面板
    function openMobileAdmin() {
      const panel = document.getElementById('m-admin');
      if (!panel) return;
      panel.style.display = 'flex';

      // 请求一次 host 当前设置
      if (conn && conn.open) {
        conn.send({ type: 'request_settings' });
      }
    }
    function closeMobileAdmin() {
      const panel = document.getElementById('m-admin');
      if (!panel) return;
      panel.style.display = 'none';
    }

    // ✅ 手机端：发送控制指令到 host
    function sendHostControl(payload) {
      if (!conn || !conn.open) return;
      conn.send({ type: 'host_control', payload });
    }

    window.onload = function() {
      const btns = document.querySelectorAll('.emoji-btn');
      btns.forEach(btn => {
        const type = btn.getAttribute('data-icon');
        if (type) { btn.appendChild(createPixelIcon(type, 3, '#fff')); }
      });

      const zoomSlider = document.getElementById('zoom-slider');
      const zoomInput = document.getElementById('zoom-input');
      const ySlider = document.getElementById('y-slider');
      const yInput = document.getElementById('y-input');

      // ✅ 允许小数：parseFloat + 不再强制整数
      zoomSlider.oninput = function() {
        zoomInput.value = this.value;
        layout.scale = parseFloat(this.value) / 100;
        applyLayout(false);
      };
      zoomInput.oninput = function() {
        let val = parseFloat(this.value);
        if (!isNaN(val)) {
          zoomSlider.value = val;
          layout.scale = val / 100;
          applyLayout(false);
        }
      };
      ySlider.oninput = function() {
        yInput.value = this.value;
        layout.y = parseFloat(this.value);
        applyLayout(false);
      };
      yInput.oninput = function() {
        let val = parseFloat(this.value);
        if (!isNaN(val)) {
          ySlider.value = val;
          layout.y = val;
          applyLayout(false);
        }
      };

      // ✅ SNOW 开关绑定（桌面端）
      const snowToggle = document.getElementById('snow-toggle');
      const snowLabel = document.getElementById('snow-toggle-label');
      if (snowToggle) {
        snowEnabled = snowToggle.checked;
        if (snowLabel) snowLabel.textContent = snowEnabled ? 'ON' : 'OFF';
        snowToggle.addEventListener('change', () => {
          snowEnabled = snowToggle.checked;
          if (snowLabel) snowLabel.textContent = snowEnabled ? 'ON' : 'OFF';
          if (!snowEnabled) {
            const snowLayer = document.getElementById('layer-snow');
            if (snowLayer) snowLayer.innerHTML = '';
          }
        });
      }

      const gameContainer = document.getElementById('desktop-view');
      gameContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.ctrlKey) {
          const zoomSpeed = 0.001;
          const newScale = layout.scale - (e.deltaY * zoomSpeed);
          layout.scale = Math.min(Math.max(0.1, newScale), 5.0);
        } else {
          const panSpeed = 1.0;
          layout.y -= e.deltaY * panSpeed;
        }
        applyLayout(true);
      }, { passive: false });

      const vfdOverlay = document.getElementById('vfd-overlay');
      for (let i = 0; i < 80; i++) {
        const arrow = document.createElement('i');
        arrow.style.setProperty('--d', i * 0.01);
        vfdOverlay.appendChild(arrow);
      }

      requestAnimationFrame(gameLoop);
      fitScreen();

      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        const step = 20 / layout.scale; const zoomStep = 0.05; let changed = false;
        switch(e.key) {
          case 'ArrowUp': layout.y -= step; changed = true; break;
          case 'ArrowDown': layout.y += step; changed = true; break;
          case 'ArrowLeft': layout.x -= step; changed = true; break;
          case 'ArrowRight': layout.x += step; changed = true; break;
          case '=': case '+': layout.scale += zoomStep; changed = true; break;
          case '-': case '_': layout.scale = Math.max(0.1, layout.scale - zoomStep); changed = true; break;
          case '0': fitScreen(); return;
        }
        if(changed) applyLayout(true);
      });

      const isMobile = new URLSearchParams(window.location.search).has('host');
      if(isMobile) {
        document.getElementById('desktop-view').style.display = 'none';
        document.getElementById('mobile-view').style.display = 'flex';
        initMobile();
      } else {
        initDesktop();
      }
    };

    function updateBarText(text, color) {
      if (currentBarText === text) return;
      currentBarText = text;
      const container = document.getElementById('bar-text');
      let content = '';
      for(let i=0; i<12; i++) { content += `<span class="bar-text-item">${text}</span>`; }
      container.innerHTML = content;
      if(color) { container.style.color = color; } else { container.style.color = ''; }
    }
    function setBarVisibility(show) {
      document.getElementById('track-display-bar').style.display = show ? 'flex' : 'none';
      if(!show) currentBarText = '';
    }
    function triggerFlash() {
      const screen = document.getElementById('track-wrapper');
      screen.classList.remove('flash-active');
      void screen.offsetWidth;
      screen.classList.add('flash-active');
    }
    function broadcast(data) {
      if(!peer || !peer.connections) return;
      Object.values(peer.connections).forEach(conns => {
        conns.forEach(conn => { if(conn.open) conn.send(data); });
      });
    }
    function fitScreen() {
      const availableW = window.innerWidth * 0.95;
      layout.scale = Math.min(availableW / (GAME_W + GAME_H), 1);
      layout.x = 0; layout.y = 0;
      applyLayout(true);
    }

    // ✅ 小数显示：zoom 输入保留 1 位小数；slider 同步小数值
    function applyLayout(updateInput = true) {
      const el = document.getElementById('track-wrapper');
      el.style.transform = `scale(${layout.scale}) translate(${layout.x}px, ${layout.y}px)`;

      if(updateInput) {
        const zoomPct = layout.scale * 100;
        document.getElementById('zoom-input').value = zoomPct.toFixed(1);
        document.getElementById('zoom-slider').value = zoomPct.toFixed(1);

        document.getElementById('y-input').value = Number(layout.y).toFixed(1);
        document.getElementById('y-slider').value = Number(layout.y);
      }
    }

    function initDesktop() {
      initEditor('pc-grid', 'pc-colors', pcGrid);
      try {
        peer = new Peer(null, PEER_CONFIG);
        peer.on('open', id => {
          const url = `${location.href}?host=${id}`;
          new QRCode(document.getElementById("qrcode"), {
            text: url, width: 86, height: 86,
            colorDark : "#000000", colorLight : "#ffffff", correctLevel: QRCode.CorrectLevel.L
          });
        });

        peer.on('connection', c => {
          c.on('data', data => {
            // ✅ 手机端请求当前设置
            if (data.type === 'request_settings') {
              const modeSel = document.getElementById('mode-select');
              c.send({
                type: 'settings',
                zoom: layout.scale * 100,
                y: layout.y,
                mode: modeSel ? modeSel.value : 'CLASSIC',
                snowEnabled: !!snowEnabled
              });
              return;
            }

            // ✅ 手机端发送 host 控制指令
            if (data.type === 'host_control' && data.payload) {
              const p = data.payload;

              if (p.action === 'set_layout') {
                const z = parseFloat(p.zoom);
                const y = parseFloat(p.y);
                if (!isNaN(z)) layout.scale = z / 100;
                if (!isNaN(y)) layout.y = y;
                applyLayout(true);
              }

              if (p.action === 'set_mode') {
                const modeSel = document.getElementById('mode-select');
                if (modeSel && p.mode) modeSel.value = p.mode;
              }

              if (p.action === 'set_snow') {
                snowEnabled = !!p.enabled;
                syncDesktopSnowUI();
              }

              if (p.action === 'add_bot') {
                spawnTestPony();
              }

              return;
            }

            // 原有逻辑
            if (data.type === 'check_reconnect') {
              const uuid = data.uuid;
              const exists = ponies.find(p => p.playerUUID === uuid) || ponyQueue.find(p => p.playerUUID === uuid);
              if (exists) c.send({ type: 'reconnect_success' });
            } else if (data.type === 'spawn') {
              const uuid = data.payload.uuid;
              const exists = ponies.find(p => p.playerUUID === uuid) || ponyQueue.find(p => p.playerUUID === uuid);
              if (!exists) requestSpawnPony(data.payload.name, data.payload.pixels, data.payload.color, uuid);

              if (gameState === 'RACING') {
                c.send({ type: 'sync_ui', label: 'WAITING', mode: 'wait' });
              }
            } else if (data.type === 'tap') {
              handleTap(data.uuid);
            } else if (data.type === 'jump') {
              handleJump(data.uuid);
            } else if (data.type === 'force_start') {
              if (data.mode) {
                const modeSel = document.getElementById('mode-select');
                if(modeSel) modeSel.value = data.mode;
              }
              if (gameState === 'ROAMING' || gameState === 'WAITING_TO_START') startCooldown();
            } else if (data.type === 'emoji') {
              triggerPonyEmoji(data.uuid, data.content);
            }
          });
        });

        peer.on('error', (err) => {
          console.error("PeerJS Error:", err);
          alert("Network Error: " + err.type + "\nTry refreshing.");
        });
      } catch(e) { console.error(e); }
    }

    function spawnTestPony() {
      const names = ["SPEEDY", "THUNDER", "BOLT", "COMET", "DASH", "FLASH", "STORM", "SHADOW", "BLAZE", "SPIRIT"];
      const rName = names[Math.floor(Math.random() * names.length)] + " " + Math.floor(Math.random()*99);
      const colorKeys = Object.keys(COLORS);
      const rColorKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
      requestSpawnPony(rName, DEFAULT_PIXELS, COLORS[rColorKey], null);
    }

    function applyTugForce(team) {
      const power = 1.5;
      if (team === 1) tugValue = Math.min(100, tugValue + power);
      else tugValue = Math.max(0, tugValue - power);
    }

    function spawnBattleSparks(x) {
      const fx = document.getElementById('layer-fx');
      const count = Math.random() < 0.5 ? 1 : 2;
      for(let i=0; i<count; i++) {
        const el = document.createElement('div');
        el.className = 'tug-spark';
        el.style.left = x + 'px';
        el.style.top = (Math.random() * GAME_H) + 'px';
        fx.appendChild(el);

        const angle = (Math.random() - 0.5) * Math.PI;
        const speed = 5 + Math.random() * 10;
        let vx = Math.cos(angle) * speed * (Math.random() < 0.5 ? 1 : -1);
        let vy = (Math.random() - 0.5) * 10;

        let life = 30;
        const tick = () => {
          life--;
          if(life <= 0) { el.remove(); return; }
          el.style.left = (parseFloat(el.style.left) + vx) + 'px';
          el.style.top = (parseFloat(el.style.top) + vy) + 'px';
          el.style.opacity = life / 30;
          vy += 0.5;
          requestAnimationFrame(tick);
        };
        tick();
      }
    }

    function handleTap(uuid) {
      if (!uuid) return;
      const pony = ponies.find(p => p.playerUUID === uuid);

      if (pony && pony.state === 'racing') {

        if (currentGameMode === 'TUG') {
          applyTugForce(pony.team);
          pony.tapCount++;
          pony.isWalkAnimating = true;
          pony.manualAnimTimer = 5;

          pony.pullOffset = (pony.team === 1 ? 35 : -35);

          const fx = document.getElementById('layer-fx');
          const shock = document.createElement('div');
          shock.className = 'shockwave';
          shock.style.left = (pony.x + 25) + 'px';
          shock.style.top = (pony.y + 25) + 'px';
          shock.style.borderColor = (pony.team === 1) ? '#2979ff' : '#ff5252';
          fx.appendChild(shock);
          setTimeout(() => shock.remove(), 400);

          if (Math.random() < 0.5) {
            const d = document.createElement('div');
            d.style.position = 'absolute';
            d.style.left = (pony.x + 20) + 'px';
            d.style.top = (pony.y + 40) + 'px';
            d.style.width = '6px'; d.style.height = '6px';
            d.style.background = '#888';
            d.style.opacity = '0.6';
            d.style.animation = 'text-vanish 0.5s forwards';
            fx.appendChild(d);
            setTimeout(() => d.remove(), 500);
          }
          return;
        }

        if (pony.isStunned) return;

        if (currentGameMode === 'RED_LIGHT' && lightState === 'RED') {
          if (pony.invincibleTimer <= 0) {
            pony.isStunned = true;
            pony.stunTimer = 60;
            pony.invincibleTimer = 90;
            pony.manualSpeed = -15;
            triggerPonyEmoji(pony.playerUUID, 'POOP');
          }
          return;
        }

        pony.isManual = true; pony.lastTapTime = Date.now(); pony.tapCount++;
        pony.name = pony.name.replace(" (BOT)", "");
        pony.manualSpeed = Math.min(pony.manualSpeed + 2.4, 18);
        pony.turboCharge = Math.min(pony.turboCharge + 20, 100);
        if (pony.manualAnimTimer === 0) pony.manualAnimTimer = 10;
      }
    }

    function handleJump(uuid) {
      if (!uuid) return;
      const pony = ponies.find(p => p.playerUUID === uuid);
      if (pony && pony.state === 'racing' && !pony.isStunned && !pony.isJumping) {
        if (currentGameMode === 'RED_LIGHT') return;
        pony.isJumping = true;
        pony.vz = 12;
        pony.isManual = true;
      }
    }

    function requestSpawnPony(name, pixels, color, uuid = null) {
      const newPony = {
        id: Math.random().toString(36).substr(2, 9),
        playerUUID: uuid, isManual: !!uuid, manualSpeed: 0, tapCount: 0, lastTapTime: Date.now(),
        name: name || 'PONY', pixels: JSON.parse(JSON.stringify(pixels || DEFAULT_PIXELS)), color: color || COLORS.CYAN,
        x: 20, y: 30 + Math.random() * (GAME_H - PONY_SIZE - 20), speed: 3.0, state: 'racing',
        hasCrown: false, isStreak: false, crownCount: 0, timer: 0, frame: 0, finishedWalking: false,
        targetX: null, targetY: null, isWalkAnimating: false, manualAnimTimer: 0, roamSpeed: 0.5,
        isTurbo: false, turboCharge: 0,
        z: 0, vz: 0, isJumping: false, isStunned: false, stunTimer: 0, invincibleTimer: 0,
        pullOffset: 0
      };
      if (gameState === 'RACING' || gameState === 'COOLDOWN' || gameState === 'WAITING_TO_START') {
        ponyQueue.push(newPony);
      } else {
        ponies.push(newPony);
        startCooldown();
      }
    }

    function startCooldown() {
      if (ponyQueue.length > 0) { ponies = ponies.concat(ponyQueue); ponyQueue = []; }

      let selected = document.getElementById('mode-select').value;

      if (selected === 'TUG' && ponies.length < 2) {
        alert("NOT ENOUGH PLAYERS FOR TUG WAR (MIN 2)");
        selected = 'CLASSIC';
        document.getElementById('mode-select').value = 'CLASSIC';
      }

      if (selected === 'RANDOM') {
        let modes = ['CLASSIC', 'HURDLE', 'RED_LIGHT'];
        if (ponies.length >= 2) modes.push('TUG');
        currentGameMode = modes[Math.floor(Math.random() * modes.length)];
      } else {
        currentGameMode = selected;
      }

      gameState = 'COOLDOWN'; cooldownTimer = 240;

      if (currentGameMode === 'TUG') {
        const allPonies = [...ponies].sort(() => Math.random() - 0.5);
        const teamMap = {};
        allPonies.forEach((p, index) => {
          p.team = (index % 2 === 0) ? 1 : -1;
          p.tapCount = 0;
          if (p.playerUUID) teamMap[p.playerUUID] = (p.team === 1) ? 'BLUE' : 'RED';
        });
        broadcast({ type: 'sync_ui', label: 'READY', mode: 'wait', teamMap: teamMap });
      } else {
        broadcast({ type: 'sync_ui', label: 'READY', mode: 'wait' });
      }

      ponies.forEach(p => {
        p.state = 'ready';
        p.manualSpeed = 0; p.tapCount = 0;
        p.isWalkAnimating = false; p.manualAnimTimer = 0; p.isTurbo = false; p.turboCharge = 0;
        p.z = 0; p.vz = 0; p.isStunned = false; p.stunTimer = 0; p.invincibleTimer = 0;
        p.pullOffset = 0;

        if (currentGameMode === 'TUG') {
          const teamMembers = ponies.filter(tm => tm.team === p.team).sort((a,b) => a.id.localeCompare(b.id));
          const myIndex = teamMembers.findIndex(tm => tm.id === p.id);
          const baseY = (GAME_H - PONY_SIZE) / 2 + 10;

          if (p.team === 1) {
            p.x = (GAME_W / 2) - 100 - (myIndex * 50);
            p.facing = 1;
          } else {
            p.x = (GAME_W / 2) + 100 + (myIndex * 50);
            p.facing = -1;
          }
          p.y = baseY;
        } else {
          p.x = 20;
          p.facing = 1;
          p.y = 30 + Math.random() * (GAME_H - PONY_SIZE - 30);
        }
      });

      document.getElementById('hud').style.display = 'none';
      document.getElementById('queue-text').style.display = 'none';
      setBarVisibility(true);

      let modeName = "CLASSIC";
      if (currentGameMode === 'RED_LIGHT') modeName = "STOP?";
      else if (currentGameMode === 'HURDLE') modeName = "JUMP";
      else if (currentGameMode === 'CLASSIC') modeName = "RUN";
      else if (currentGameMode === 'TUG') modeName = "TEAM";

      updateBarText(modeName, "#ffffff");

      const tugLayer = document.getElementById('tug-layer');
      if (currentGameMode === 'TUG' && tugLayer) {
        tugValue = 50;
        tugLayer.style.display = 'block';
        const bZone = document.getElementById('tug-blue-zone');
        if(bZone) bZone.style.width = '50%';
        const rZone = document.getElementById('tug-red-zone');
        if(rZone) rZone.style.width = '50%';

        const targetX = (window.innerWidth / 2) - (1700 * layout.scale);
        layout.x = targetX;
        applyLayout(false);
      } else if (tugLayer) {
        document.getElementById('game-screen').className = '';
        lightState = 'GREEN';
        tugLayer.style.display = 'none';
      }

      obstacles = [];
    }

    function startRace() {
      updateBarText("GO!", "#ffffff");

      let statusText = "STATUS: RACING";
      let mobileInfo = "RUN (TAP)";

      const tugLayer = document.getElementById('tug-layer');
      if(tugLayer) tugLayer.style.display = 'none';

      if (currentGameMode === 'HURDLE') {
        statusText = "STATUS: JUMP";
        mobileInfo = "TAP: RUN / UP: JUMP";
        obstacles = [];
        for(let ox = 500; ox < FINISH_X - 200; ox += (400 + Math.random() * 300)) {
          obstacles.push({ x: ox, width: 10, passed: false });
        }
      } else if (currentGameMode === 'RED_LIGHT') {
        statusText = "STATUS: STOP?";
        mobileInfo = "WATCH!";
        obstacles = [];
        lightState = 'GREEN';
        redLightTimer = (120 + Math.random() * 100) * 0.8;
        document.getElementById('game-screen').classList.add('bg-green');
        playSignalSound('GREEN');
      } else if (currentGameMode === 'TUG') {
        statusText = "TEAM BATTLE";
        mobileInfo = "PULL!";
        tugValue = 50;
        obstacles = [];

        if(tugLayer) tugLayer.style.display = 'block';

        const teamMap = {};
        ponies.forEach(p => {
          if (p.playerUUID) teamMap[p.playerUUID] = (p.team === 1) ? 'BLUE' : 'RED';
        });
        broadcast({ type: 'sync_ui', label: 'PULL!', mode: 'tug', teamMap: teamMap });
      } else {
        statusText = "STATUS: RUN";
        obstacles = [];
      }

      const hud = document.getElementById('hud');
      hud.style.display = 'block';
      hud.innerText = statusText;

      const vfdOverlay = document.getElementById('vfd-overlay');
      vfdOverlay.classList.remove('vfd-active'); void vfdOverlay.offsetWidth; vfdOverlay.classList.add('vfd-active');

      const textItems = document.querySelectorAll('.bar-text-item');
      textItems.forEach((item, index) => {
        item.style.animation = `text-vanish 0.05s linear forwards ${delay = 0.02 + (index * 0.06)}s`;
      });

      setTimeout(() => {
        if (gameState === 'RACING') {
          setBarVisibility(false);
          vfdOverlay.classList.remove('vfd-active');
        }
      }, 1500);

      ponies.forEach(p => {
        if (currentGameMode !== 'TUG') p.speed = 3.0 + Math.random() * 2.5;
        p.state = 'racing';
        p.finishedWalking = false;
        p.z = 0; p.vz = 0; p.isStunned = false; p.stunTimer = 0; p.invincibleTimer = 0;
        if(p.isManual) p.lastTapTime = Date.now();
      });

      if (currentGameMode !== 'TUG') {
        grass = [];
        gameState = 'RACING';
        broadcast({ type: 'sync_ui', label: 'RUN!', mode: 'mash', infoText: mobileInfo });
      } else {
        gameState = 'RACING';
      }
    }

    function gameLoop() { updateGameLogic(); draw(); requestAnimationFrame(gameLoop); }

    function updateGameLogic() {
      // ✅ 下雪开关生效
      if (snowEnabled) spawnSnow();

      const alert = document.getElementById('queue-text');
      const hud = document.getElementById('hud');

      if (gameState === 'COOLDOWN' && currentGameMode === 'TUG') {
        ponies.forEach(p => { p.frame++; });
      }

      if (gameState === 'WAITING_TO_START') {
        waitTimer--;
        alert.style.display = 'block';
        const sec = Math.ceil(waitTimer / 60);
        alert.innerText = `NEXT ROUND IN ${sec}`;
        if (sec > 0 && lastBroadcastText !== sec) {
          broadcast({ type: 'sync_ui', label: `STARTING ${sec}`, mode: 'wait' });
          lastBroadcastText = sec;
        }
        updatePoniesMovement();
        if (waitTimer <= 0) startCooldown();

      } else if (gameState === 'COOLDOWN') {
        cooldownTimer--;
        alert.style.display = 'none';

        if (cooldownTimer > 180) {
          // show mode name
        } else {
          const sec = Math.ceil(cooldownTimer / 60);
          updateBarText(sec.toString(), '#ffffff');
          if (cooldownTimer % 60 === 59) triggerFlash();
          if (sec > 0 && lastBroadcastText !== sec) {
            broadcast({ type: 'sync_ui', label: sec.toString(), mode: 'wait' });
            lastBroadcastText = sec;
          }
        }
        if (cooldownTimer <= 0) startRace();
        if (currentGameMode !== 'TUG') updatePoniesMovement();

      } else if (gameState === 'RACING') {
        if (ponyQueue.length > 0) {
          alert.style.display = 'block';
          alert.innerText = `${ponyQueue.length} WAITING NEXT ROUND`;
        } else {
          alert.style.display = 'none';
        }

        if (currentGameMode === 'TUG') {
          ponies.forEach(p => {
            if (!p.playerUUID && Math.random() < 0.015) {
              if (p.team === 1) tugValue = Math.min(100, tugValue + 1.0);
              else tugValue = Math.max(0, tugValue - 1.0);
              p.isWalkAnimating = true;
              p.pullOffset = (p.team === 1 ? 10 : -10);
            }
          });

          const bZone = document.getElementById('tug-blue-zone');
          if(bZone) bZone.style.width = tugValue + '%';
          const rZone = document.getElementById('tug-red-zone');
          if(rZone) rZone.style.width = (100 - tugValue) + '%';

          const targetX = (window.innerWidth / 2) - (1700 * layout.scale);
          layout.x = targetX;
          applyLayout(false);

          const battleFront = GAME_W * (tugValue / 100);
          spawnBattleSparks(battleFront);

          ponies.forEach(p => {
            const teamMembers = ponies.filter(tm => tm.team === p.team).sort((a,b) => a.id.localeCompare(b.id));
            const myIndex = teamMembers.findIndex(tm => tm.id === p.id);

            let basePositionX;
            if (p.team === 1) basePositionX = battleFront - 80 - (myIndex * 45);
            else basePositionX = battleFront + 80 + (myIndex * 45);

            const desiredX = basePositionX + (p.pullOffset || 0);

            const smoothFactor = 0.15;
            p.x = p.x + (desiredX - p.x) * smoothFactor;

            if (p.pullOffset) p.pullOffset *= 0.8;
            if (Math.abs(p.pullOffset) < 1) p.pullOffset = 0;

            if (Math.abs(desiredX - p.x) < 1 && !p.isManual) p.isWalkAnimating = false;
            else p.isWalkAnimating = true;
          });

          if (tugValue >= 95) endTugWar(1);
          else if (tugValue <= 5) endTugWar(-1);

        } else if (currentGameMode === 'RED_LIGHT') {
          redLightTimer--;
          if (redLightTimer <= 0) {
            const screen = document.getElementById('game-screen');
            screen.className = '';
            if (lightState === 'GREEN') {
              lightState = 'YELLOW';
              redLightTimer = 30;
              screen.classList.add('bg-yellow');
              updateBarText("STOP?", "#ffb300");
              setBarVisibility(true);
              playSignalSound('YELLOW');
            } else if (lightState === 'YELLOW') {
              lightState = 'RED';
              redLightTimer = 60 + Math.random() * 90;
              screen.classList.add('bg-red');
              updateBarText("STOP!", "#ff5252"); setBarVisibility(true);
              playSignalSound('RED');
            } else if (lightState === 'RED') {
              lightState = 'GREEN';
              redLightTimer = (100 + Math.random() * 150) * 0.8;
              screen.classList.add('bg-green');
              updateBarText("GO!", "#69f0ae");
              playSignalSound('GREEN');
              setTimeout(() => { if (lightState === 'GREEN') setBarVisibility(false); }, 500);
            }
          }
          updatePoniesMovement();
          checkRaceEnd();
        } else {
          updatePoniesMovement();
          checkRaceEnd();
        }

      } else if (gameState === 'ROAMING') {
        hud.style.display = 'block';
        hud.innerText = "NOWHERE TO RUN";
        document.getElementById('game-screen').className = '';
        if (ponyQueue.length > 0) {
          alert.style.display = 'block';
          alert.innerText = `${ponyQueue.length} WAITING NEXT ROUND`;
        } else {
          alert.style.display = 'none';
        }
        updatePoniesMovement();
      }

      const active = ponies.filter(p => p.state === 'racing');
      if (active.length === 0 && Math.random() < 0.2) {
        const segmentSize = 500;
        const totalSegments = Math.ceil(GAME_W / segmentSize);
        for(let i=0; i<totalSegments; i++) {
          const startX = i * segmentSize;
          const endX = (i + 1) * segmentSize;
          const count = grass.filter(g => g.x >= startX && g.x < endX).length;
          if (count < 2 && Math.random() < 0.05) {
            grass.push({ x: startX + Math.random() * segmentSize, y: 20 + Math.random() * (GAME_H - 40) });
          }
        }
      }
    }

    function endTugWar(winnerTeam) {
      gameState = 'FINISHED';
      const totalPlayers = ponies.length;
      const eliminationCount = Math.max(0, totalPlayers - 10);
      let losers = ponies.filter(p => p.team !== winnerTeam);
      losers.sort((a, b) => a.tapCount - b.tapCount);
      const toExplode = new Set(losers.slice(0, eliminationCount).map(p => p.id));
      let mvpPony = null;
      let maxTaps = -1;

      ponies.forEach(p => {
        p.hasCrown = false;
        p.isStreak = false;

        if (toExplode.has(p.id)) {
          explode(p);
        } else {
          p.state = 'roaming';
          p.targetX = null;
          p.targetY = null;
          p.timer = 0;
          if (p.team === winnerTeam) {
            if (p.tapCount > maxTaps) {
              maxTaps = p.tapCount;
              mvpPony = p;
            }
          }
        }
      });

      if (mvpPony) {
        mvpPony.hasCrown = true;
        mvpPony.isStreak = true;
      }

      const winnerText = "WIN";
      const winnerColor = (winnerTeam === 1) ? "#2979ff" : "#ff0000";
      updateBarText(winnerText, winnerColor);
      setBarVisibility(true);

      const tugLayer = document.getElementById('tug-layer');
      if(tugLayer) tugLayer.style.display = 'none';

      setTimeout(() => {
        if (ponyQueue.length > 0) {
          gameState = 'WAITING_TO_START';
          waitTimer = 180;
        } else {
          gameState = 'ROAMING';
          setBarVisibility(false);
          layout.x = 0;
          applyLayout(false);
          broadcast({ type: 'sync_ui', label: 'DONE', mode: 'wait' });

          setTimeout(() => {
            if (gameState === 'ROAMING') {
              broadcast({ type: 'sync_ui', label: 'START RACE', mode: 'start' });
            }
          }, 2000);
        }
      }, 4000);
    }

    function checkRaceEnd() {
      const finished = ponies.filter(p => p.state === 'finished');
      let raceOverTrigger = false;
      if (ponies.length > 10) {
        if (finished.length >= 10) raceOverTrigger = true;
      } else {
        if (ponies.length > 0 && finished.length === ponies.length) raceOverTrigger = true;
      }

      if (raceOverTrigger) {
        if (ponies.length > 10) {
          const losers = ponies.filter(p => p.state === 'racing');
          losers.forEach(p => explode(p));
          ponies = ponies.filter(p => p.state === 'finished');
        }

        ponies.forEach(p => {
          p.state = 'roaming';
          p.timer = 0;
          p.targetX = null;
          p.targetY = null;
          p.isWalkAnimating = false;
          p.isTurbo = false;
          p.turboCharge = 0;
        });

        if (ponyQueue.length > 0) {
          gameState = 'WAITING_TO_START';
          waitTimer = 180;
        } else {
          gameState = 'ROAMING';
          broadcast({ type: 'sync_ui', label: 'DONE', mode: 'wait' });
          setTimeout(() => {
            if (gameState === 'ROAMING') broadcast({ type: 'sync_ui', label: 'START RACE', mode: 'start' });
          }, 3000);
        }

        document.getElementById('game-screen').className = '';
        setBarVisibility(false);
      }
    }

    function spawnTrail(p) {
      const fxLayer = document.getElementById('layer-fx');
      const count = Math.random() < 0.5 ? 1 : 2;
      for (let i = 0; i < count; i++) {
        const el = document.createElement('div');
        el.className = 'trail-segment';
        el.style.left = (p.x - 20 + Math.random() * 10) + 'px';
        el.style.top = (p.y + 15 + Math.random() * 15) + 'px';
        el.style.background = p.color;
        el.style.boxShadow = `0 0 0px ${p.color}`;
        fxLayer.appendChild(el);
        setTimeout(() => el.remove(), 400);
      }
    }

    function spawnSnow() {
      const snowLayer = document.getElementById('layer-snow');
      const count = Math.random() < 0.5 ? 1 : 2;
      for(let i=0; i<count; i++) {
        const el = document.createElement('div');
        el.className = 'snowflake';
        el.style.left = (Math.random() * GAME_W) + 'px';
        const size = 2 + Math.random() * 3;
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        el.style.opacity = 0.4 + Math.random() * 0.6;
        const duration = 2000 + Math.random() * 2000;
        el.style.animationDuration = duration + 'ms';
        snowLayer.appendChild(el);
        setTimeout(() => el.remove(), duration + 100);
      }
    }

    function updatePoniesMovement() {
      let winnerFoundThisFrame = false;
      const finishedCount = ponies.filter(p => p.state === 'finished').length;

      ponies.forEach(p => {
        p.frame++;
        p.isWalkAnimating = false;
        p.isTurbo = false;

        if (p.manualAnimTimer > 0) p.manualAnimTimer--;
        p.turboCharge = Math.max(0, p.turboCharge - 1);

        if (p.invincibleTimer > 0) p.invincibleTimer--;

        if (p.state === 'ready') {
          if (currentGameMode !== 'TUG') p.x = 20;
          return;
        }

        if (p.state === 'racing') {
          if (p.isStunned) {
            p.stunTimer--;
            if (p.stunTimer <= 0) p.isStunned = false;
            p.isWalkAnimating = false;
            if (p.manualSpeed < 0) { p.x += p.manualSpeed; p.manualSpeed *= 0.9; }
          } else {
            if (p.playerUUID) {
              if (p.isManual) {
                if (Date.now() - p.lastTapTime > 10000) {
                  p.isManual = false;
                  if (!p.name.includes("(BOT)")) p.name += " (BOT)";
                }
              }
            }

            if (p.isManual) {
              p.manualSpeed *= 0.95;
              if (p.manualSpeed < 0.1) p.manualSpeed = 0;
              p.x += p.manualSpeed;
              p.isWalkAnimating = p.manualSpeed > 0.1;
            } else {
              if (currentGameMode === 'RED_LIGHT' && lightState === 'RED') {
                if (Math.random() < 0.02) p.x += 2;
              } else {
                p.x += p.speed * (0.9 + Math.random() * 0.2);
                p.isWalkAnimating = true;
                if (currentGameMode === 'HURDLE' && !p.isJumping) {
                  const nearestObs = obstacles.find(o => o.x > p.x && o.x < p.x + 150);
                  if (nearestObs && Math.random() < 0.15) {
                    p.isJumping = true; p.vz = 12;
                  }
                }
              }
            }

            if (p.isJumping) {
              p.z += p.vz;
              p.vz -= 0.8;
              if (p.z <= 0) {
                p.z = 0; p.vz = 0; p.isJumping = false;
              }
            }

            if (p.invincibleTimer <= 0) {
              if (currentGameMode === 'HURDLE') {
                obstacles.forEach(obs => {
                  if (p.x + 40 > obs.x && p.x < obs.x + obs.width) {
                    if (p.z < 20) {
                      p.isStunned = true;
                      p.stunTimer = 30;
                      p.invincibleTimer = 90;
                      p.manualSpeed = 0;
                      p.x = obs.x - 10;
                      triggerPonyEmoji(p.playerUUID, 'POOP');
                    }
                  }
                });
              }
            }

            if (p.turboCharge > 60 && Math.random() < 0.4) spawnTrail(p);
            if (p.turboCharge > 30) p.isTurbo = true;

            p.facing = 1;

            if (p.x >= FINISH_X) {
              if (p.state === 'racing') {
                p.state = 'finished';
                p.isTurbo = false;
                if (p.playerUUID) broadcast({ type: 'player_finished', uuid: p.playerUUID });

                if (finishedCount === 0 && !winnerFoundThisFrame && gameState === 'RACING') {
                  winnerFoundThisFrame = true;
                  if (p.hasCrown) p.isStreak = true;
                  else { p.hasCrown = true; p.isStreak = false; }
                  ponies.forEach(o => { if(o.id !== p.id) { o.hasCrown = false; o.isStreak = false; }});
                }
              }
            }
          }
        } else if (p.state === 'finished') {
          p.z = 0;
          if (p.x < GAME_W - 50) { p.x += 0.8; p.finishedWalking = true; p.isWalkAnimating = true; }
          else { p.finishedWalking = false; aiBehavior(p, true); }
        } else {
          p.finishedWalking = false;
          aiBehavior(p, false);
        }

        p.x = Math.max(0, Math.min(GAME_W - 38, p.x));
        p.y = Math.max(p.hasCrown ? 35 : 20, Math.min(GAME_H - 44 - 6, p.y));
      });
    }

    function aiBehavior(p, restrictFinish) {
      const maxY = GAME_H - 44;
      const minY = p.hasCrown ? 35 : 20;

      if (p.state === 'roaming' || p.state === 'finished') {
        for(let i=0; i<grass.length; i++) {
          const g = grass[i];
          if (Math.abs(g.x - p.x) < 50 && Math.abs(g.y - p.y) < 50) {
            p.state = 'eating';
            p.timer = 50;
            grass.splice(i, 1);
            p.targetX = null;
            p.targetY = null;
            return;
          }
        }

        if (p.timer-- <= 0) {
          const action = Math.random();
          if (action < 0.3) {
            p.targetX = (p.x < GAME_W / 2) ? GAME_W - 100 - Math.random() * 400 : 50 + Math.random() * 400;
            p.targetY = minY + Math.random() * (maxY - minY);
            p.timer = 400 + Math.random() * 400;
            p.roamSpeed = 2.0;
          } else if (action < 0.8) {
            p.targetX = p.x + (Math.random() - 0.5) * 600;
            p.targetY = minY + Math.random() * (maxY - minY);
            p.timer = 100 + Math.random() * 200;
            p.roamSpeed = 0.8;
          } else {
            p.targetX = null; p.targetY = null;
            p.timer = 60 + Math.random() * 120;
            p.roamSpeed = 0;
          }
        }

        if (p.targetX !== null && p.targetY !== null) {
          const dx = p.targetX - p.x;
          const dy = p.targetY - p.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 5) {
            p.targetX = null;
            p.targetY = null;
            p.timer = 0;
          } else {
            const speed = p.roamSpeed || 0.5;
            p.x += (dx / dist) * speed;
            p.y += (dy / dist) * speed;
            p.facing = Math.sign(dx) || 1;
            p.isWalkAnimating = true;
          }
        }
      } else if (p.state === 'eating') {
        if (p.timer-- <= 0) p.state = 'roaming';
      }
    }

    function explode(p) {
      const fx = document.getElementById('layer-fx');
      for(let i=0; i<20; i++) {
        const el = document.createElement('div');
        el.className = 'explosion';
        el.style.left = (p.x + 19) + 'px';
        el.style.top = (p.y + 19) + 'px';
        el.style.background = p.color;
        fx.appendChild(el);

        const angle = Math.random() * 6.28;
        const spd = 3 + Math.random() * 5;
        let vx = Math.cos(angle) * spd;
        let vy = Math.sin(angle) * spd;
        let life = 40;

        const tick = () => {
          if (life-- <= 0) return el.remove();
          el.style.left = (parseFloat(el.style.left) + vx) + 'px';
          el.style.top = (parseFloat(el.style.top) + vy) + 'px';
          el.style.opacity = life/40;
          requestAnimationFrame(tick);
        };
        tick();
      }

      const grassCount = Math.floor(Math.random() * 3) + 1;
      for(let i=0; i<grassCount; i++) {
        grass.push({ x: p.x + (Math.random()-0.5) * 60, y: p.y + (Math.random()-0.5) * 40 });
      }

      ponies = ponies.filter(target => target.id !== p.id);

      if (p.playerUUID) broadcast({ type: 'eliminated', uuid: p.playerUUID });
    }

    function draw() {
      const grassL = document.getElementById('layer-grass');
      let htmlContent = grass.map(g => `<div class="grass" style="left:${g.x}px; top:${g.y}px"></div>`).join('');
      if (gameState === 'RACING' || gameState === 'COOLDOWN') {
        htmlContent += obstacles.map(o => `<div class="obstacle" style="left:${o.x}px; height:30px;"></div>`).join('');
      }
      grassL.innerHTML = htmlContent;

      const ponyL = document.getElementById('layer-pony');
      const nodes = Array.from(ponyL.children);
      const ids = new Set(ponies.map(p => p.id));
      nodes.forEach(n => { if(!ids.has(n.id)) n.remove(); });

      ponies.forEach(p => {
        let el = document.getElementById(p.id);
        if (!el) {
          el = document.createElement('div');
          el.id = p.id;
          el.className = 'entity';
          el.innerHTML = `
            <div class="aura"></div>
            <div class="crown-container" style="display: none;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="#facc15" stroke="#facc15" stroke-width="2">
                <path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"></path>
              </svg>
            </div>
            <div class="name-tag">${p.name}</div>
            <div class="p-grid" style="display:grid; grid-template-columns:repeat(11,1fr); width:100%; height:100%;"></div>
          `;
          ponyL.appendChild(el);
        }

        el.style.transform = `translate(${p.x}px, ${p.y - p.z}px) scale(1.1)`;
        el.style.zIndex = Math.floor(p.y);

        if (p.isStunned) {
          el.style.filter = "grayscale(100%) opacity(0.5)";
        } else if (p.invincibleTimer > 0) {
          el.style.filter = (Math.floor(p.invincibleTimer / 5) % 2 === 0) ? "opacity(0.3)" : "opacity(0.8)";
        } else {
          el.style.filter = "none";
        }

        const crownC = el.querySelector('.crown-container');
        crownC.style.display = p.hasCrown ? 'flex' : 'none';

        el.querySelector('.aura').style.display = p.isStreak ? 'block' : 'none';
        el.querySelector('.name-tag').style.color = p.hasCrown ? '#facc15' : p.color;

        const gridEl = el.querySelector('.p-grid');
        if (p.isTurbo) {
          gridEl.classList.add('trail-active');
          gridEl.style.setProperty('--trail-c', p.color);
        } else {
          gridEl.classList.remove('trail-active');
          gridEl.style.removeProperty('--trail-c');
        }

        let frameStep = 0;
        if (p.isManual && p.state === 'racing') frameStep = (p.manualAnimTimer > 0) ? 1 : 0;
        else if (p.isWalkAnimating) frameStep = Math.floor(p.frame / 5) % 2;

        gridEl.style.transform = `scaleX(${p.facing || 1})`;

        let html = '';
        for(let y=0; y<11; y++) {
          let row = p.pixels[y];
          if (p.state === 'eating') {
            if (y <= 5) row = (y >= 2) ? p.pixels[y - 2] : [0,0,0,0,0,0,0,0,0,0,0];
          } else if (frameStep === 1 && y > 8) {
            row = [row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[0]];
          }
          for(let x=0; x<11; x++) {
            if (row[x]) html += `<div style="background:${p.color}; width:100%; height:100%; grid-column:${x+1}; grid-row:${y+1}"></div>`;
          }
        }
        gridEl.innerHTML = html;
      });
    }

    function initMobile() {
      playerUUID = localStorage.getItem('horse_uuid');
      if (!playerUUID) {
        playerUUID = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('horse_uuid', playerUUID);
      }

      initEditor('m-grid', 'm-colors', mobileGrid);

      // ✅ 五次点击标题进入隐藏面板
      const titleEl = document.getElementById('m-title');
      if (titleEl) {
        titleEl.addEventListener('click', () => {
          mTitleTapCount++;
          if (mTitleTapTimer) clearTimeout(mTitleTapTimer);
          mTitleTapTimer = setTimeout(() => { mTitleTapCount = 0; }, 1200);

          if (mTitleTapCount >= 5) {
            mTitleTapCount = 0;
            openMobileAdmin();
            vibrate(30);
          }
        });
      }

      // ✅ 绑定隐藏面板按钮
      const applyBtn = document.getElementById('m-admin-apply');
      const addBotBtn = document.getElementById('m-admin-addbot');
      const backBtn = document.getElementById('m-admin-back');
      const snowCb = document.getElementById('m-admin-snow');
      const snowLbl = document.getElementById('m-admin-snow-label');
      const modeSel = document.getElementById('m-admin-mode');

      if (applyBtn) {
        applyBtn.addEventListener('click', () => {
          const z = parseFloat(document.getElementById('m-admin-zoom').value);
          const y = parseFloat(document.getElementById('m-admin-y').value);
          sendHostControl({ action: 'set_layout', zoom: z, y: y });
          vibrate(10);
        });
      }
      if (addBotBtn) {
        addBotBtn.addEventListener('click', () => {
          sendHostControl({ action: 'add_bot' });
          vibrate(10);
        });
      }
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          closeMobileAdmin();
          vibrate(10);
        });
      }
      if (snowCb) {
        snowCb.addEventListener('change', () => {
          const enabled = snowCb.checked;
          if (snowLbl) snowLbl.textContent = enabled ? 'ON' : 'OFF';
          sendHostControl({ action: 'set_snow', enabled });
          vibrate(10);
        });
      }
      if (modeSel) {
        modeSel.addEventListener('change', () => {
          sendHostControl({ action: 'set_mode', mode: modeSel.value });
          vibrate(10);
        });
      }

      try {
        peer = new Peer(null, PEER_CONFIG);
        peer.on('open', () => {
          conn = peer.connect(new URLSearchParams(window.location.search).get('host'));
          conn.on('open', () => {
            document.getElementById('m-status').innerText = "CONNECTED";
            document.getElementById('m-status').style.color = "#69f0ae";
            conn.send({ type: 'check_reconnect', uuid: playerUUID });

            // 可选：连接成功后也请求一次设置，方便面板首次打开就有值
            conn.send({ type: 'request_settings' });
          });

          conn.on('data', data => {
            // ✅ host 返回设置：填充隐藏面板
            if (data.type === 'settings') {
              const z = (typeof data.zoom === 'number') ? data.zoom : 100;
              const y = (typeof data.y === 'number') ? data.y : 0;
              const mode = data.mode || 'CLASSIC';
              const sn = !!data.snowEnabled;

              const zEl = document.getElementById('m-admin-zoom');
              const yEl = document.getElementById('m-admin-y');
              const mEl = document.getElementById('m-admin-mode');
              const sEl = document.getElementById('m-admin-snow');
              const sLbl = document.getElementById('m-admin-snow-label');

              if (zEl) zEl.value = Number(z).toFixed(1);
              if (yEl) yEl.value = Number(y).toFixed(1);
              if (mEl) mEl.value = mode;
              if (sEl) sEl.checked = sn;
              if (sLbl) sLbl.textContent = sn ? 'ON' : 'OFF';
              return;
            }

            if (data.type === 'reconnect_success') {
              document.getElementById('m-editor-ui').style.display = 'none';
              document.getElementById('m-controller').style.display = 'flex';
            }
            else if (data.type === 'sync_ui') {
              if (mobileBtnState === 'dead') return;

              const btn = document.getElementById('m-btn');
              const info = document.getElementById('m-info');
              const modeWrapper = document.getElementById('m-mode-wrapper');

              mobileBtnState = data.mode;
              btn.className = 'push-btn';

              modeWrapper.style.display = 'none';

              if (data.mode === 'tug') {
                btn.classList.add('btn-mash');
                btn.innerText = "PULL!";

                if (data.teamMap && data.teamMap[playerUUID]) {
                  const myTeam = data.teamMap[playerUUID];
                  info.innerText = `TEAM ${myTeam}`;
                  info.style.color = (myTeam === 'RED') ? '#ff5252' : '#2979ff';
                  btn.classList.add(myTeam === 'RED' ? 'btn-team-red' : 'btn-team-blue');
                } else {
                  info.innerText = "SPECTATING";
                }
              }
              else if (data.mode === 'wait') {
                btn.classList.add('btn-wait');
                btn.innerText = data.label;
                info.innerText = "GET READY...";
                info.style.color = "#888";
              }
              else if (data.mode === 'mash') {
                btn.classList.add('btn-mash');
                btn.innerText = "RUN";
                info.innerText = data.infoText || "TAP TO RUN";
                randomizeMusic();
              }
              else if (data.mode === 'start') {
                btn.classList.add('btn-start');
                btn.innerText = data.label;
                info.innerText = "RACE FINISHED";
                modeWrapper.style.display = 'flex';
              }
            }
            else if (data.type === 'eliminated' && data.uuid === playerUUID) {
              const btn = document.getElementById('m-btn');
              const info = document.getElementById('m-info');
              mobileBtnState = 'dead';
              btn.className = 'push-btn btn-dead';
              btn.innerText = "CREATE\nAGAIN";
              info.innerText = "ELIMINATED";
              document.getElementById('m-mode-wrapper').style.display = 'none';
              vibrate([100, 50, 100]);
            }
            else if (data.type === 'player_finished' && data.uuid === playerUUID) {
              mobileBtnState = 'finished';
              const btn = document.getElementById('m-btn');
              btn.className = 'push-btn btn-wait';
              btn.innerText = "DONE";
              document.getElementById('m-info').innerText = "WAITING...";
              document.getElementById('m-mode-wrapper').style.display = 'none';
              vibrate([200]);
            }
          });
        });
      } catch(e) { console.error(e); }
    }

    function handleMotion(event) {
      const acc = event.acceleration;
      if (!acc) return;
      const magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
      if (magnitude > 15) {
        const now = Date.now();
        if (now - lastShakeTime > 500) {
          lastShakeTime = now;
          if(conn) conn.send({ type: 'jump', uuid: playerUUID });
          vibrate(200);
        }
      }
    }

    const mBtn = document.getElementById('m-btn');
    let touchStartY = 0;
    let touchStartTime = 0;

    mBtn.addEventListener('touchstart', (e) => {
      if (mobileBtnState === 'dead') { resetMobile(); return; }
      if (mobileBtnState === 'finished') return;
      if (mobileBtnState === 'start') {
        const selectedMode = document.getElementById('m-mode-select').value;
        if(conn) conn.send({ type: 'force_start', mode: selectedMode });
        vibrate(50);
        return;
      }
      if (mobileBtnState !== 'mash' && mobileBtnState !== 'tug') return;

      e.preventDefault();
      touchStartY = e.changedTouches[0].clientY;
      touchStartTime = Date.now();
      mBtn.style.transform = 'scale(0.95)';
    }, {passive: false});

    mBtn.addEventListener('touchend', (e) => {
      if (mobileBtnState !== 'mash' && mobileBtnState !== 'tug') return;
      e.preventDefault();
      mBtn.style.transform = 'scale(1)';

      const touchEndY = e.changedTouches[0].clientY;
      const diffY = touchStartY - touchEndY;

      // ✅ 关闭上滑跳跃：swipeJumpEnabled=false 时，上滑也只当作 tap
      if (swipeJumpEnabled && diffY > 50) {
        if(conn) conn.send({ type: 'jump', uuid: playerUUID });
        vibrate(100);
      } else {
        if(conn) conn.send({ type: 'tap', uuid: playerUUID });
        initAudio(); playNextNote();
        vibrate(15);
      }
    });

    function sendMobile() {
      if(!conn) return alert("Not Connected!");
      const nameInput = document.getElementById('m-name');
      let name = nameInput.value.trim().replace(/[^a-zA-Z0-9]/g, '');
      if (!name) name = "PLAYER";
      name = name.toUpperCase();

      let hasPixels = false;
      for(let r=0; r<11; r++) {
        for(let c=0; c<11; c++) {
          if (mobileGrid[r][c] === 1) { hasPixels = true; break; }
        }
        if(hasPixels) break;
      }
      if (!hasPixels) { alert("CANVAS IS EMPTY"); return; }

      initAudio();
      randomizeMusic();

      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') window.addEventListener('devicemotion', handleMotion);
          })
          .catch(console.error);
      } else {
        window.addEventListener('devicemotion', handleMotion);
      }

      conn.send({ type: 'spawn', payload: { name: name, pixels: mobileGrid, color: selectedColor, uuid: playerUUID } });
      document.getElementById('m-editor-ui').style.display = 'none';
      document.getElementById('m-controller').style.display = 'flex';
    }

    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function triggerPonyEmoji(uuid, emojiType) {
      const pony = ponies.find(p => p.playerUUID === uuid);
      if (!pony) return;
      const pEl = document.getElementById(pony.id);
      if (!pEl) return;

      let container;
      if (emojiType === 'FACE') {
        container = document.createElement('div');
        container.className = 'pop-text';
        container.innerText = "?";
        container.style.color = pony.color;
      } else {
        container = document.createElement('div');
        container.className = 'pixel-emoji-container';
        container.appendChild(createPixelIcon(emojiType, 2, pony.color));
      }

      pEl.appendChild(container);

      if (audioCtx && audioCtx.state === 'running') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      }

      setTimeout(() => container.remove(), 2500);
    }

    function sendEmoji(type) {
      if(!conn) return;
      conn.send({ type: 'emoji', uuid: playerUUID, content: type });
      const btn = event.currentTarget;
      btn.style.transform = 'scale(0.8)';
      setTimeout(() => btn.style.transform = 'scale(1)', 100);
      vibrate(10);
    }

    function resetMobile() {
      document.getElementById('m-controller').style.display = 'none';
      document.getElementById('m-editor-ui').style.display = 'block';
      renderGrid('m-grid', mobileGrid, selectedColor);
      mobileBtnState = 'wait';
    }
    function clearMobile() { clearGridData(mobileGrid); renderGrid('m-grid', mobileGrid, selectedColor); }
    function clearDesktop() { clearGridData(pcGrid); renderGrid('pc-grid', pcGrid, selectedColor); }
    function clearGridData(grid) { for(let r=0; r<11; r++) for(let c=0; c<11; c++) grid[r][c] = 0; }
    function openDesktopEditor() { renderGrid('pc-grid', pcGrid, selectedColor); document.getElementById('modal-editor').style.display = 'flex'; }
    function savePCPony() {
      let name = document.getElementById('pc-name').value.trim().replace(/[^a-zA-Z0-9]/g, '');
      if (!name) name = "PLAYER";
      name = name.toUpperCase();
      requestSpawnPony(name, pcGrid, selectedColor);
      document.getElementById('modal-editor').style.display = 'none';
    }

    function initEditor(gridId, colorId, dataGrid) {
      const gridEl = document.getElementById(gridId);
      const colorEl = document.getElementById(colorId);
      colorEl.innerHTML = '';

      Object.values(COLORS).forEach(c => {
        const dot = document.createElement('div');
        dot.className = `c-dot ${c === selectedColor ? 'active' : ''}`;
        dot.style.background = c;
        dot.onclick = () => {
          selectedColor = c;
          renderGrid(gridId, dataGrid, selectedColor);
          Array.from(colorEl.children).forEach(d => d.classList.remove('active'));
          dot.classList.add('active');
        };
        colorEl.appendChild(dot);
      });

      renderGrid(gridId, dataGrid, selectedColor);

      let drawing = false, eraseMode = false;

      const getCellCoords = (e) => {
        const t = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList.contains('editor-cell')) {
          return { r: parseInt(el.dataset.r), c: parseInt(el.dataset.c), el: el };
        }
        return null;
      };

      const startDraw = (e) => {
        if(e.cancelable) e.preventDefault();
        drawing = true;
        const cell = getCellCoords(e);
        if (cell) {
          eraseMode = dataGrid[cell.r][cell.c] === 1;
          updateCell(cell.r, cell.c, cell.el);
        }
      };

      const moveDraw = (e) => {
        if (!drawing) return;
        if(e.cancelable) e.preventDefault();
        const cell = getCellCoords(e);
        if (cell) updateCell(cell.r, cell.c, cell.el);
      };

      const endDraw = () => { drawing = false; };

      const updateCell = (r, c, el) => {
        const targetVal = eraseMode ? 0 : 1;
        if (dataGrid[r][c] !== targetVal) {
          dataGrid[r][c] = targetVal;
          if (targetVal === 1) {
            el.style.background = selectedColor;
            el.style.boxShadow = `0 0 5px ${selectedColor}`;
          } else {
            el.style.background = '#000';
            el.style.boxShadow = 'none';
          }
        }
      };

      gridEl.onmousedown = gridEl.ontouchstart = startDraw;
      window.onmousemove = window.ontouchmove = moveDraw;
      window.onmouseup = window.ontouchend = endDraw;
    }

    function renderGrid(id, data, color) {
      const el = document.getElementById(id);
      el.innerHTML = '';
      data.forEach((row, r) => row.forEach((val, c) => {
        const cell = document.createElement('div');
        cell.className = 'editor-cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        if(val) {
          cell.style.background = color;
          cell.style.boxShadow = `0 0 5px ${color}`;
        } else {
          cell.style.background = '#000';
        }
        el.appendChild(cell);
      }));
    }
  </script>
</body>
</html>
