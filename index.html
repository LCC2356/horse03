<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HORSE RUNRUN - 1BIT DUNGEON</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #101010;
            --primary: #eeeeee;
            --secondary: #444444;
            --accent: #ffffff;
            --game-w: 3400px;
            --game-h: 120px; /* 稍微增高以容纳地砖 */
        }

        /* 1-BIT 抖动纹理生成 */
        .pattern-checker {
            background-image: linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%, #222),
                              linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%, #222);
            background-position: 0 0, 2px 2px;
            background-size: 4px 4px;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0; padding: 0;
            background-color: #050505;
            font-family: 'VT323', monospace;
            color: var(--primary);
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; flex-direction: column;
            position: relative;
            image-rendering: pixelated; /* 关键：强制像素化 */
        }

        .hidden { display: none !important; }

        #desktop-view {
            position: absolute; inset: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
        }

        /* 背景装饰层 */
        .dungeon-wall {
            position: absolute; inset: 0;
            background-color: #000;
            opacity: 1;
            z-index: 0;
        }
        
        /* 砖块纹理 */
        .wall-bricks {
            position: absolute; inset: 0;
            background-image: 
                linear-gradient(335deg, #111 23px, transparent 23px),
                linear-gradient(155deg, #111 23px, transparent 23px),
                linear-gradient(335deg, #111 23px, transparent 23px),
                linear-gradient(155deg, #111 23px, transparent 23px);
            background-size: 58px 58px;
            background-position: 0px 2px, 4px 35px, 29px 31px, 34px 6px;
            opacity: 0.5;
        }

        #game-container {
            position: absolute;
            left: 50%; top: 50%;
            width: 0; height: 0;
            display: flex; justify-content: center; align-items: center;
        }

        #game-screen {
            width: var(--game-w); height: var(--game-h);
            background: #000; position: relative;
            /* 改为粗白边框 */
            border-top: 4px solid var(--primary);
            border-bottom: 8px solid var(--primary); /* 地板更厚 */
            box-shadow: none;
            overflow: hidden;
            flex-shrink: 0;
        }

        /* 装饰：藤蔓 (用CSS模拟像素点) */
        .vine {
            position: absolute; top: 0; width: 4px; background: transparent;
            image-rendering: pixelated;
            z-index: 5;
            pointer-events: none;
        }
        /* 简单的像素藤蔓生成 */
        .vine::after {
            content: ''; position: absolute; top:0; left:0; width: 4px; height: 100%;
            background: linear-gradient(to bottom, 
                #fff 0%, #fff 10%, 
                transparent 10%, transparent 15%, 
                #fff 15%, #fff 30%,
                transparent 30%, transparent 35%,
                #fff 35%, #fff 40%,
                transparent 40%, transparent 60%,
                #fff 60%, #fff 80%
            );
            box-shadow: 4px 10px 0 #fff, -4px 25px 0 #fff;
            opacity: 0.5;
        }

        /* === 模式样式调整 === */
        /* 去除发光，改为背景图案变化 */
        .bg-green { background: #000 !important; border-color: #fff !important; }
        .bg-yellow { background: #222 !important; border-color: #aaa !important; } 
        /* 红灯模式下使用斜线纹理 */
        .bg-red { 
            background: repeating-linear-gradient(45deg, #220000, #220000 10px, #000 10px, #000 20px) !important; 
            border-color: #fff !important; 
        }

        /* === 拔河模式 === */
        #tug-layer {
            position: absolute; inset: 0; z-index: 1; display: none;
        }
        /* 左侧：黑色+网格 */
        #tug-blue-zone {
            position: absolute; left: 0; top: 0; bottom: 0; width: 50%; 
            background: #000; 
            border-right: 4px dashed #fff; 
            z-index: 2;
            transition: width 0.1s linear; 
        }
        /* 右侧：白色+抖动纹理 */
        #tug-red-zone {
            position: absolute; right: 0; top: 0; bottom: 0; width: 50%;
            background: #fff;
            background-image: radial-gradient(#000 1px, transparent 1px);
            background-size: 4px 4px;
            z-index: 1;
            transition: width 0.1s linear; 
        }
        
        .icon-vs {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; color: #fff; 
            background: #000; padding: 0 10px; border: 2px solid #fff;
            z-index: 10;
        }

        #track-wrapper {
            display: flex;
            width: calc(var(--game-w) + var(--game-h));
            height: var(--game-h);
            flex-shrink: 0;
            position: relative;
        }

        #side-qr-box {
            width: var(--game-h); height: var(--game-h);
            background: #fff; /* 纯白背景 */
            border: 4px solid var(--primary);
            border-left: none;
            display: flex; justify-content: center; align-items: center;
            position: relative; flex-shrink: 0;
            color: #000;
        }

        .join-label {
            position: absolute; bottom: 2px; left: 0; width: 100%;
            text-align: center; font-size: 20px; color: #000;
            font-weight: bold;
        }

        .flash-active {
            animation: invert-flash 0.1s steps(2);
        }
        @keyframes invert-flash {
            0% { filter: invert(0); }
            50% { filter: invert(1); }
            100% { filter: invert(0); }
        }

        .grid-bg {
            position: absolute; inset: 0; opacity: 0.3;
            /* 简单的垂直线条模拟柱子 */
            background-image: linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 100px 100%;
            pointer-events: none;
        }
        .finish-line {
            position: absolute; top: 0; bottom: 0; right: 400px; width: 20px;
            background-image: repeating-linear-gradient(45deg, #fff 0, #fff 10px, #000 10px, #000 20px);
            border: 2px solid #fff;
            opacity: 1; z-index: 0;
        }

        /* HUD */
        .hud { 
            position: absolute; bottom: 105%; right: 0px; 
            font-size: 40px; color: #fff; background: #000; 
            padding: 5px 10px; border: 2px solid #fff;
            z-index: 110; 
        }

        #track-display-bar {
            position: absolute; top: 50%; transform: translateY(-50%);
            left: 0; width: 100%; height: 100px;
            display: none; align-items: center; justify-content: center;
            z-index: 100; pointer-events: none;
        }

        .bar-text-item {
            font-size: 80px; font-weight: bold; width: 260px;
            display: flex; justify-content: center; flex-shrink: 0; margin: 0;
            color: #fff !important; /* 强制白色 */
            text-shadow: 4px 4px 0 #000; /* 黑色阴影增加可读性 */
            -webkit-text-stroke: 1px #000;
        }

        .queue-alert {
            position: absolute; top: -50px; right: 20px;
            font-size: 24px; color: #fff; background: #000; border: 1px solid #fff; padding: 5px;
            display: none; z-index: 20;
        }

        #vfd-overlay { display: none; } /* 移除 VFD 效果 */

        .entity { position: absolute; width: 44px; height: 44px; will-change: transform; }
        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            width: 100%; height: 100%;
            transform-origin: bottom center;
            transition: transform 0.2s;
        }

        .crown-container {
            position: absolute; top: -31px; left: 50%; transform: translateX(-50%);
            width: 18px; height: 18px;
            animation: bounce 1s infinite; z-index: 10;
            display: flex; flex-direction: column-reverse; align-items: center;
            filter: drop-shadow(1px 1px 0 #000); /* 皇冠加边框 */
        }
        .aura { display: none !important; } /* 移除光环 */

        .name-tag {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            font-size: 20px; white-space: nowrap; color: #fff !important; 
            background: #000; padding: 0 4px;
            border: 1px solid #fff;
        }
        /* 装饰性草地改为小石块 */
        .grass { 
            position: absolute; width: 6px; height: 6px; 
            background: #fff; box-shadow: 2px 2px 0 #444; 
        }
        
        /* 障碍物改为板条箱样式 */
        .obstacle {
            position: absolute;
            width: 10px; height: 30px; 
            background: #000; 
            border: 2px solid #fff; 
            z-index: 5; bottom: 5px;
            /* 内部画一个X */
            background: linear-gradient(to top right, transparent calc(50% - 1px), #fff, transparent calc(50% + 1px)),
                        linear-gradient(to top left, transparent calc(50% - 1px), #fff, transparent calc(50% + 1px));
        }

        .tug-spark {
            position: absolute; width: 4px; height: 4px; background: #000;
            border: 1px solid #fff;
            pointer-events: none; z-index: 20;
        }

        .shockwave {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 10px; height: 10px; border-radius: 50%;
            border: 2px solid #fff !important; /* 强制白色 */
            pointer-events: none; z-index: 5;
            animation: shock-expand 0.4s steps(5) forwards; /* 步进动画 */
        }

        .explosion { position: absolute; width: 4px; height: 4px; background: #fff; border: 1px solid #000; pointer-events: none; }

        .trail-segment {
            position: absolute; height: 4px; width: 50px; 
            background: #fff !important; /* 强制白色 */
            opacity: 0.5;
            animation: trail-fade 0.2s steps(3) forwards;
            z-index: 90;
            background-image: radial-gradient(#000 20%, transparent 20%); background-size: 4px 4px;
        }

        /* 表情 */
        .pop-text {
            color: #fff; font-size: 28px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'VT323', monospace;
            background: #000; padding: 2px 5px; border: 1px solid #fff;
        }

        /* === 底部控制栏 (Retro UI) === */
        #bottom-controls {
            position: fixed; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 15px;
            padding: 15px; background: #000;
            border: 2px solid #fff; 
            box-shadow: 4px 4px 0 #fff; /* 像素阴影 */
            z-index: 1000;
        }
        #qrcode {
            background: white; padding: 3px; width: 90px; height: 90px;
            display: flex; justify-content: center; align-items: center; border: 2px solid #000;
        }

        .control-group {
            display: flex; flex-direction: column; gap: 5px; border-left: 2px solid #fff; padding-left: 15px; width: 140px;
        }
        .control-label { font-size: 1rem; color: #fff; background: #000; display: inline-block; margin-bottom: 2px;}

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 5px 0; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 10px; background: #fff; border: 2px solid #000; }
        input[type=range]::-webkit-slider-thumb { height: 20px; width: 10px; background: #000; border: 2px solid #fff; -webkit-appearance: none; margin-top: -7px; cursor: pointer; }
        
        input[type="number"], select { 
            background: #000; border: 2px solid #fff; color: #fff; 
            font-family: 'VT323', monospace; font-size: 1.4rem; padding: 2px; border-radius: 0; 
        }

        .btn {
            background: #000; border: 2px solid #fff; color: #fff;
            padding: 10px 20px; font-family: 'VT323', monospace; font-size: 1.5rem;
            cursor: pointer; text-transform: uppercase; 
            transition: all 0.1s; margin-left: 5px;
            box-shadow: 4px 4px 0 #444;
        }
        .btn:hover { background: #fff; color: #000; }
        .btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #444; }

        /* === 编辑器模态框 === */
        #modal-editor {
            background: rgba(0,0,0,0.95); 
            /* 抖动遮罩 */
            background-image: radial-gradient(#222 1px, transparent 1px); background-size: 4px 4px;
        }
        .modal-content {
            background: #000; border: 4px solid #fff; padding: 30px;
            box-shadow: 10px 10px 0 #222;
        }
        .editor-grid {
            gap: 1px; background: #444; border: 2px solid #fff;
        }
        .editor-cell { width: 28px; height: 28px; background: #000; }
        .c-dot { border: 2px solid #444; box-shadow: none; }
        .c-dot.active { border-color: #fff; transform: scale(1.2); background-image: radial-gradient(#000 20%, transparent 20%); background-size: 4px 4px;}

        /* === 手机端界面 (Game Boy 风格) === */
        #mobile-view {
            background: #111; padding: 20px;
            background-image: radial-gradient(#222 1px, transparent 1px); background-size: 8px 8px;
        }
        .m-header { border-bottom: 4px solid #fff; }
        .m-status { background: #000; border: 2px solid #fff; color: #fff; }
        input[type="text"] {
            background: #000; border: 2px solid #fff; color: #fff; border-radius: 0;
        }
        .m-canvas-container {
            background: #000; border: 4px solid #fff; border-radius: 0;
        }
        
        .push-btn {
            background: #000; border: 4px solid #fff; color: #fff;
            border-radius: 10px; /* 稍微圆角 */
            box-shadow: 0 8px 0 #444;
            transition: all 0.1s;
        }
        .push-btn:active { transform: translateY(8px); box-shadow: none; }
        
        .btn-wait { background: #222 !important; color: #888 !important; border-color: #444 !important; box-shadow: none !important; }
        .btn-mash { background: #fff !important; color: #000 !important; border-color: #000 !important; box-shadow: 0 8px 0 #888 !important; }
        
        /* 队伍颜色重写为更暗/更亮的单色以适应复古风 */
        .btn-team-red { 
            background: #000 !important; border-color: #fff !important; color: #fff !important;
            /* 斜线纹理代表红队 */
            background-image: repeating-linear-gradient(45deg, #000, #000 10px, #444 10px, #444 20px) !important;
        }
        .btn-team-blue { 
            background: #fff !important; border-color: #000 !important; color: #000 !important;
            /* 点状纹理代表蓝队 */
            background-image: radial-gradient(#000 2px, transparent 2px) !important; background-size: 6px 6px !important;
        }

        /* 手机端表情按钮 */
        .emoji-btn {
            background: #000; border: 2px solid #fff; color: #fff; border-radius: 0;
            box-shadow: 4px 4px 0 #444;
        }
        .emoji-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #444; }

    </style>
</head>
<body>

    <div id="desktop-view">
        <div class="wall-bricks"></div> <div class="vine" style="left: 10%; height: 40%;"></div>
        <div class="vine" style="left: 12%; height: 20%;"></div>
        <div class="vine" style="left: 80%; height: 50%;"></div>
        <div class="vine" style="left: 85%; height: 30%;"></div>
        
        <div id="game-container">
            <div id="track-wrapper">
                <div id="game-screen">
                    <div class="grid-bg"></div>
                    
                    <div id="tug-layer">
                        <div id="tug-red-zone"></div> 
                        <div id="tug-blue-zone">
                            <span class="tug-icon" style="position:absolute; right: 10px; top:50%; transform:translateY(-50%); color: #fff; font-size:30px;">&lt;&lt;&lt;</span> 
                        </div>
                        <div class="icon-vs">VS</div>
                    </div>

                    <div class="finish-line"></div>

                    <div id="hud" class="hud">NOWHERE TO RUN</div>

                    <div id="track-display-bar">
                        <div class="bar-container" id="bar-text"></div>
                    </div>

                    <div id="queue-text" class="queue-alert"></div>
                    <div id="vfd-overlay"></div>
                    <div id="layer-snow"></div>
                    <div id="layer-grass"></div>
                    <div id="layer-pony"></div>
                    <div id="layer-fx"></div>
                </div>
                <div id="side-qr-box">
                    <div id="qrcode"></div>
                    <div class="join-label">SCAN</div>
                </div>
            </div>
        </div>

        <div id="bottom-controls">
            <div class="control-group" style="border-left: none;">
                <span class="control-label">ZOOM</span>
                <input type="range" id="zoom-slider" min="1" max="500" step="1" value="100">
                <div class="input-wrapper">
                    <input type="number" id="zoom-input" value="100" min="1" max="500">
                    <span class="unit-label">%</span>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Y OFFSET</span>
                <input type="range" id="y-slider" min="-1200" max="1200" step="10" value="0">
                <div class="input-wrapper">
                    <input type="number" id="y-input" value="0" step="1">
                    <span class="unit-label">PX</span>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">GAME MODE</span>
                <select id="mode-select">
                    <option value="RANDOM">RANDOM</option>
                    <option value="CLASSIC">RUN</option> 
                    <option value="HURDLE">JUMP</option>
                    <option value="RED_LIGHT">STOP?</option> 
                    <option value="TUG">TEAM</option>
                </select>
            </div>

            <button class="btn" onclick="spawnTestPony()">+ BOT</button>
            <button class="btn" onclick="openDesktopEditor()">+ PONY</button>
        </div>
    </div>

    <div id="modal-editor" class="hidden">
        <div class="modal-content">
            <h2 style="margin:0; color:#fff; text-shadow: 2px 2px #000;">DESIGN RUNNER</h2>
            <input type="text" id="pc-name" placeholder="ENTER NAME" maxlength="8" value="PLAYER" style="margin:15px 0;">
            <div class="color-picker" id="pc-colors"></div>
            <div id="pc-grid" class="editor-grid" style="margin: 15px 0;"></div>
            <div style="display: flex; gap: 20px; width: 100%;">
                <button class="btn" style="flex:1" onclick="document.getElementById('modal-editor').style.display='none'">CANCEL</button>
                <button class="btn" style="flex:1" onclick="clearDesktop()">CLEAR</button>
                <button class="btn" style="flex:1; background:#fff; color:#000;" onclick="savePCPony()">SPAWN</button>
            </div>
        </div>
    </div>

    <div id="mobile-view" style="display: none;">
        <div id="m-editor-ui">
            <div class="m-header">
                <span class="m-title" style="color:#fff;">1-BIT RUNNER</span>
                <span id="m-status" class="m-status">Wait...</span>
            </div>
            <div class="m-controls">
                <input type="text" id="m-name" placeholder="ENTER NAME" maxlength="8">
                <div class="color-picker" id="m-colors"></div>
            </div>
            <div class="m-canvas-container">
                <div id="m-grid" class="editor-grid"></div>
            </div>
            <div class="m-footer">
                <button class="btn btn-flex" onclick="clearMobile()">CLEAR</button>
                <button class="btn btn-flex" style="background:#fff; color:#000;" onclick="sendMobile()">JOIN</button>
            </div>
        </div>

        <div id="m-controller">
            <div id="m-info" class="controller-info">GET READY</div>
            
            <div id="m-mode-wrapper">
                <select id="m-mode-select">
                    <option value="RANDOM">RANDOM</option>
                    <option value="CLASSIC">RUN</option> <option value="HURDLE">JUMP</option>
                    <option value="RED_LIGHT">STOP?</option>
                    <option value="TUG">TEAM</option>
                </select>
            </div>

            <div id="m-btn" class="push-btn btn-wait">WAIT</div>
            
            <div class="emoji-bar">
                <div class="emoji-btn" onclick="sendEmoji('HEART')" data-icon="HEART"></div>
                <div class="emoji-btn" onclick="sendEmoji('POOP')" data-icon="POOP"></div>
                <div class="emoji-btn" onclick="sendEmoji('BOLT')" data-icon="BOLT"></div>
                <div class="emoji-btn" onclick="sendEmoji('FACE')" style="font-size: 2rem;">?</div>
            </div>
        </div>
    </div>

    <script>
        // 保持原有的 JavaScript 逻辑，仅仅修改颜色配置
        const GAME_W = 3400;
        const GAME_H = 120; // 配合CSS高度
        const PONY_SIZE = 50;
        const FINISH_X = GAME_W - 400;

        // 修改为黑白风格的颜色，虽然变量名没变，但值变了以适应UI
        const COLORS = { 
            CYAN:'#ffffff',  // 白色
            YELLOW:'#cccccc', // 浅灰
            RED:'#888888',    // 中灰
            GREEN:'#444444',  // 深灰
            PURPLE:'#aaaaaa', // 另一种灰
            WHITE:'#ffffff', 
            BLUE:'#000000'    // 黑色
        };

        const DEFAULT_PIXELS = [
            [0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0], [0,0,0,0,0,0,0,1,1,1,1], [0,1,0,0,0,0,1,1,1,0,0],
            [1,0,1,1,1,1,1,1,1,0,0], [1,0,1,1,1,1,1,1,1,0,0], [0,0,1,1,1,1,1,1,1,0,0], [0,0,1,0,1,0,1,0,1,0,0], [0,0,1,0,1,0,1,0,1,0,0], [0,0,1,0,1,0,1,0,1,0,0]
        ];

        const PIXEL_ART_MAPS = {
            'HEART': [ [0,1,1,0,1,1,0], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [0,1,1,1,1,1,0], [0,0,1,1,1,0,0], [0,0,0,1,0,0,0] ],
            'POOP': [ [0,0,0,1,0,0,0], [0,0,1,1,1,0,0], [0,1,1,1,1,1,0], [1,0,1,1,1,0,1], [1,1,1,1,1,1,1] ],
            'BOLT': [ [0,0,1,1,1,0], [0,1,1,1,0,0], [1,1,1,1,1,0], [0,0,0,1,1,0], [0,0,1,1,0,0], [0,0,1,0,0,0] ]
        };

        const SONGS = {
            'JINGLE': [ 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 392.0, 261.6, 293.7, 329.6, 349.2, 349.2, 349.2, 349.2, 349.2, 329.6, 329.6, 329.6, 293.7, 293.7, 329.6, 293.7, 392.0 ],
            'MERRY': [ 261.6, 349.2, 349.2, 392.0, 349.2, 329.6, 293.7, 293.7, 293.7, 392.0, 392.0, 440.0, 392.0, 349.2, 329.6, 261.6, 261.6, 440.0, 440.0, 466.2, 440.0, 392.0, 349.2, 293.7, 261.6, 261.6, 293.7, 392.0, 329.6, 349.2 ],
            'DECK': [ 523.3, 493.9, 440.0, 392.0, 349.2, 329.6, 293.7, 261.6, 293.7, 329.6, 349.2, 293.7, 329.6, 293.7, 261.6 ]
        };

        const SOUND_STYLES = {
            'GAMEBOY': { type: 'square', decay: 0.1, attack: 0.01 },
            'FLUTE': { type: 'sine', decay: 0.3, attack: 0.05 },
            'LASER': { type: 'sawtooth', decay: 0.15, attack: 0.01 },
            'CRYSTAL': { type: 'triangle', decay: 0.5, attack: 0.01 },
            'TUBA': { type: 'square', decay: 0.2, attack: 0.1 },
            'PIANO': { type: 'triangle', decay: 0.3, attack: 0.001 },
            'BANJO': { type: 'sawtooth', decay: 0.1, attack: 0.001 }
        };
        const STYLE_KEYS = Object.keys(SOUND_STYLES);

        let noteIndex = 0;
        let myCurrentSongKey = 'JINGLE';
        let myStyleKey = 'GAMEBOY';

        let ponies = [];
        let ponyQueue = [];
        let grass = [];
        let obstacles = []; 
        let gameState = 'ROAMING';
        let cooldownTimer = 0;
        let waitTimer = 0;
        
        let currentGameMode = 'CLASSIC'; 
        let redLightTimer = 0;
        let lightState = 'GREEN'; 

        let tugValue = 50; 
        
        let peer = null, conn = null;
        let pcGrid = JSON.parse(JSON.stringify(DEFAULT_PIXELS));
        let mobileGrid = JSON.parse(JSON.stringify(DEFAULT_PIXELS));
        let selectedColor = COLORS.CYAN;
        let playerUUID = null;

        let mobileBtnState = 'wait';
        let audioCtx = null;
        let lastTapTime = 0;
        
        let layout = { scale: 1.0, x: 0, y: 0 };
        let currentBarText = '';
        let lastBroadcastText = '';

        let lastShakeTime = 0; 

        const PEER_CONFIG = {
            debug: 2,
            config: {
                'iceServers': [
                    { url: 'stun:stun.l.google.com:19302' },
                    { url: 'stun:stun1.l.google.com:19302' }
                ]
            }
        };

        /* ==================== FUNCTIONS ==================== */

        function vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }

        function createPixelIcon(type, pixelSize = 2, color = '#fff') {
            const container = document.createElement('div');
            container.className = 'pixel-icon-base';
            container.style.width = pixelSize + 'px';
            container.style.height = pixelSize + 'px';
            const map = PIXEL_ART_MAPS[type] || PIXEL_ART_MAPS['HEART'];
            let boxShadow = '';
            for(let y=0; y<map.length; y++) {
                for(let x=0; x<map[y].length; x++) {
                    if (map[y][x] === 1) { boxShadow += `${x*pixelSize}px ${y*pixelSize}px ${color},`; }
                }
            }
            container.style.boxShadow = boxShadow.slice(0, -1);
            const widthOffset = (7 * pixelSize) / 2;
            container.style.transform = `translateX(-${widthOffset}px)`;
            return container;
        }

        function playSignalSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;
            
            gain.connect(audioCtx.destination);
            osc.connect(gain);

            if (type === 'GREEN') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'YELLOW') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'RED') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        function playNextNote() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const songArr = SONGS[myCurrentSongKey] || SONGS['JINGLE'];
            let freq = songArr[noteIndex % songArr.length];
            while (freq === 0) {
                 noteIndex++;
                 freq = songArr[noteIndex % songArr.length];
            }
            noteIndex++;
            const style = SOUND_STYLES[myStyleKey] || SOUND_STYLES['GAMEBOY'];
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = style.type;
            osc.frequency.setValueAtTime(freq, now); 
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + style.attack);
            gain.gain.exponentialRampToValueAtTime(0.01, now + style.attack + style.decay); 
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + style.attack + style.decay + 0.1);
        }

        function randomizeMusic() {
            const songKeys = Object.keys(SONGS);
            myCurrentSongKey = songKeys[Math.floor(Math.random() * songKeys.length)];
            myStyleKey = STYLE_KEYS[Math.floor(Math.random() * STYLE_KEYS.length)];
            noteIndex = 0; 
        }

        window.onload = function() {
            const btns = document.querySelectorAll('.emoji-btn');
            btns.forEach(btn => {
                const type = btn.getAttribute('data-icon');
                if (type) { btn.appendChild(createPixelIcon(type, 3, '#fff')); }
            });

            const zoomSlider = document.getElementById('zoom-slider');
            const zoomInput = document.getElementById('zoom-input');
            const ySlider = document.getElementById('y-slider');
            const yInput = document.getElementById('y-input');

            zoomSlider.oninput = function() { zoomInput.value = this.value; layout.scale = this.value / 100; applyLayout(false); };
            zoomInput.oninput = function() { let val = parseFloat(this.value); if(val) { zoomSlider.value = val; layout.scale = val / 100; applyLayout(false); } };
            ySlider.oninput = function() { yInput.value = this.value; layout.y = parseFloat(this.value); applyLayout(false); };
            yInput.oninput = function() { let val = parseFloat(this.value); if(!isNaN(val)) { ySlider.value = val; layout.y = val; applyLayout(false); } };

            const gameContainer = document.getElementById('desktop-view');
            gameContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.ctrlKey) {
                    const zoomSpeed = 0.001;
                    const newScale = layout.scale - (e.deltaY * zoomSpeed);
                    layout.scale = Math.min(Math.max(0.1, newScale), 5.0);
                } else {
                    const panSpeed = 1.0;
                    layout.y -= e.deltaY * panSpeed;
                }
                applyLayout(true);
            }, { passive: false });

            requestAnimationFrame(gameLoop);
            fitScreen();

            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                const step = 20 / layout.scale; const zoomStep = 0.05; let changed = false;
                switch(e.key) {
                    case 'ArrowUp': layout.y -= step; changed = true; break;
                    case 'ArrowDown': layout.y += step; changed = true; break;
                    case 'ArrowLeft': layout.x -= step; changed = true; break;
                    case 'ArrowRight': layout.x += step; changed = true; break;
                    case '=': case '+': layout.scale += zoomStep; changed = true; break;
                    case '-': case '_': layout.scale = Math.max(0.1, layout.scale - zoomStep); changed = true; break;
                    case '0': fitScreen(); return;
                }
                if(changed) applyLayout(true);
            });

            const isMobile = new URLSearchParams(window.location.search).has('host');
            if(isMobile) {
                document.getElementById('desktop-view').style.display = 'none';
                document.getElementById('mobile-view').style.display = 'flex';
                initMobile();
            } else {
                initDesktop();
            }
        };

        function updateBarText(text, color) {
            if (currentBarText === text) return;
            currentBarText = text;
            const container = document.getElementById('bar-text');
            let content = '';
            for(let i=0; i<12; i++) { content += `<span class="bar-text-item">${text}</span>`; }
            container.innerHTML = content;
            // 颜色在CSS里强制为白，这里只保留文字内容更新
        }
        function setBarVisibility(show) { document.getElementById('track-display-bar').style.display = show ? 'flex' : 'none'; if(!show) currentBarText = ''; }
        function triggerFlash() { const screen = document.getElementById('track-wrapper'); screen.classList.remove('flash-active'); void screen.offsetWidth; screen.classList.add('flash-active'); }
        function broadcast(data) { if(!peer || !peer.connections) return; Object.values(peer.connections).forEach(conns => { conns.forEach(conn => { if(conn.open) conn.send(data); }); }); }
        function fitScreen() { const availableW = window.innerWidth * 0.95; layout.scale = Math.min(availableW / (GAME_W + GAME_H), 1); layout.x = 0; layout.y = 0; applyLayout(true); }
        function applyLayout(updateInput = true) { const el = document.getElementById('track-wrapper'); el.style.transform = `scale(${layout.scale}) translate(${layout.x}px, ${layout.y}px)`; if(updateInput) { document.getElementById('zoom-input').value = Math.round(layout.scale * 100); document.getElementById('zoom-slider').value = Math.round(layout.scale * 100); document.getElementById('y-input').value = Math.round(layout.y); document.getElementById('y-slider').value = Math.round(layout.y); } }

        function initDesktop() {
            initEditor('pc-grid', 'pc-colors', pcGrid);
            try {
                peer = new Peer(null, PEER_CONFIG);
                peer.on('open', id => {
                    const url = `${location.href}?host=${id}`;
                    new QRCode(document.getElementById("qrcode"), {
                        text: url, width: 86, height: 86,
                        colorDark : "#000000", colorLight : "#ffffff", correctLevel: QRCode.CorrectLevel.L
                    });
                });
                peer.on('connection', c => {
                    c.on('data', data => {
                        if (data.type === 'check_reconnect') {
                            const uuid = data.uuid;
                            const exists = ponies.find(p => p.playerUUID === uuid) || ponyQueue.find(p => p.playerUUID === uuid);
                            if (exists) c.send({ type: 'reconnect_success' });
                        } else if (data.type === 'spawn') {
                            const uuid = data.payload.uuid;
                            const exists = ponies.find(p => p.playerUUID === uuid) || ponyQueue.find(p => p.playerUUID === uuid);
                            if (!exists) requestSpawnPony(data.payload.name, data.payload.pixels, data.payload.color, uuid);
                            
                            if (gameState === 'RACING') {
                                c.send({ type: 'sync_ui', label: 'WAITING', mode: 'wait' });
                            }
                            
                        } else if (data.type === 'tap') {
                            handleTap(data.uuid);
                        } else if (data.type === 'jump') {
                            handleJump(data.uuid);
                        } else if (data.type === 'force_start') {
                            if (data.mode) {
                                const modeSel = document.getElementById('mode-select');
                                if(modeSel) modeSel.value = data.mode;
                            }
                            if (gameState === 'ROAMING' || gameState === 'WAITING_TO_START') startCooldown();
                        } else if (data.type === 'emoji') {
                            triggerPonyEmoji(data.uuid, data.content);
                        }
                    });
                });
                peer.on('error', (err) => { console.error("PeerJS Error:", err); alert("Network Error: " + err.type + "\nTry refreshing."); });
            } catch(e) { console.error(e); }
        }

        function spawnTestPony() {
            const names = ["SPEEDY", "THUNDER", "BOLT", "COMET", "DASH", "FLASH", "STORM", "SHADOW", "BLAZE", "SPIRIT"];
            const rName = names[Math.floor(Math.random() * names.length)] + " " + Math.floor(Math.random()*99);
            const colorKeys = Object.keys(COLORS); const rColorKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
            requestSpawnPony(rName, DEFAULT_PIXELS, COLORS[rColorKey], null);
        }

        function applyTugForce(team) {
            const power = 1.5; 
            if (team === 1) {
                tugValue = Math.min(100, tugValue + power);
            } else {
                tugValue = Math.max(0, tugValue - power);
            }
        }

        function spawnBattleSparks(x) {
            const fx = document.getElementById('layer-fx');
            const count = Math.random() < 0.5 ? 1 : 2;
            for(let i=0; i<count; i++) {
                const el = document.createElement('div');
                el.className = 'tug-spark';
                el.style.left = x + 'px';
                el.style.top = (Math.random() * GAME_H) + 'px';
                fx.appendChild(el);
                
                const angle = (Math.random() - 0.5) * Math.PI;
                const speed = 5 + Math.random() * 10;
                let vx = Math.cos(angle) * speed * (Math.random() < 0.5 ? 1 : -1);
                let vy = (Math.random() - 0.5) * 10;
                
                let life = 30;
                const tick = () => {
                    life--;
                    if(life <= 0) { el.remove(); return; }
                    el.style.left = (parseFloat(el.style.left) + vx) + 'px';
                    el.style.top = (parseFloat(el.style.top) + vy) + 'px';
                    el.style.opacity = life / 30;
                    vy += 0.5; 
                    requestAnimationFrame(tick);
                };
                tick();
            }
        }

        function handleTap(uuid) {
            if (!uuid) return;
            const pony = ponies.find(p => p.playerUUID === uuid);
            
            if (pony && pony.state === 'racing') {
                
                if (currentGameMode === 'TUG') {
                    applyTugForce(pony.team);
                    pony.tapCount++; 
                    pony.isWalkAnimating = true;
                    pony.manualAnimTimer = 5;

                    pony.pullOffset = (pony.team === 1 ? 35 : -35); 
                    
                    const fx = document.getElementById('layer-fx');
                    const shock = document.createElement('div');
                    shock.className = 'shockwave';
                    shock.style.left = (pony.x + 25) + 'px'; 
                    shock.style.top = (pony.y + 25) + 'px';
                    fx.appendChild(shock);
                    setTimeout(() => shock.remove(), 400);

                    if (Math.random() < 0.5) {
                        const d = document.createElement('div');
                        d.style.position = 'absolute';
                        d.style.left = (pony.x + 20) + 'px';
                        d.style.top = (pony.y + 40) + 'px';
                        d.style.width = '6px'; d.style.height = '6px';
                        d.style.background = '#888';
                        d.style.opacity = '0.6';
                        d.style.animation = 'text-vanish 0.5s forwards';
                        fx.appendChild(d);
                        setTimeout(() => d.remove(), 500);
                    }
                    return;
                }

                if (pony.isStunned) return;

                if (currentGameMode === 'RED_LIGHT' && lightState === 'RED') {
                    if (pony.invincibleTimer <= 0) {
                        pony.isStunned = true;
                        pony.stunTimer = 60; 
                        pony.invincibleTimer = 90;
                        pony.manualSpeed = -15; 
                        triggerPonyEmoji(p.playerUUID, 'POOP');
                    }
                    return;
                }

                pony.isManual = true; pony.lastTapTime = Date.now(); pony.tapCount++;
                pony.name = pony.name.replace(" (BOT)", "");
                pony.manualSpeed = Math.min(pony.manualSpeed + 2.4, 18);
                pony.turboCharge = Math.min(pony.turboCharge + 20, 100);
                if (pony.manualAnimTimer === 0) pony.manualAnimTimer = 10;
            }
        }
        
        function handleJump(uuid) {
            if (!uuid) return;
            const pony = ponies.find(p => p.playerUUID === uuid);
            if (pony && pony.state === 'racing' && !pony.isStunned && !pony.isJumping) {
                if (currentGameMode === 'RED_LIGHT') return;
                pony.isJumping = true;
                pony.vz = 12; 
                pony.isManual = true; 
            }
        }

        function requestSpawnPony(name, pixels, color, uuid = null) {
            const newPony = {
                id: Math.random().toString(36).substr(2, 9),
                playerUUID: uuid, isManual: !!uuid, manualSpeed: 0, tapCount: 0, lastTapTime: Date.now(),
                name: name || 'PONY', pixels: JSON.parse(JSON.stringify(pixels || DEFAULT_PIXELS)), color: color || COLORS.CYAN,
                x: 20, y: 30 + Math.random() * (GAME_H - PONY_SIZE - 20), speed: 3.0, state: 'racing',
                hasCrown: false, isStreak: false, crownCount: 0, timer: 0, frame: 0, finishedWalking: false,
                targetX: null, targetY: null, isWalkAnimating: false, manualAnimTimer: 0, roamSpeed: 0.5,
                isTurbo: false, turboCharge: 0,
                z: 0, vz: 0, isJumping: false, isStunned: false, stunTimer: 0, invincibleTimer: 0,
                pullOffset: 0 
            };
            if (gameState === 'RACING' || gameState === 'COOLDOWN' || gameState === 'WAITING_TO_START') {
                ponyQueue.push(newPony); 
            } else {
                ponies.push(newPony); startCooldown();
            }
        }

        function startCooldown() {
            if (ponyQueue.length > 0) { ponies = ponies.concat(ponyQueue); ponyQueue = []; }

            let selected = document.getElementById('mode-select').value;
            
            if (selected === 'TUG' && ponies.length < 2) {
                alert("NOT ENOUGH PLAYERS FOR TUG WAR (MIN 2)");
                selected = 'CLASSIC'; 
                document.getElementById('mode-select').value = 'CLASSIC';
            }

            if (selected === 'RANDOM') {
                let modes = ['CLASSIC', 'HURDLE', 'RED_LIGHT'];
                if (ponies.length >= 2) modes.push('TUG'); 
                currentGameMode = modes[Math.floor(Math.random() * modes.length)];
            } else {
                currentGameMode = selected;
            }

            gameState = 'COOLDOWN'; cooldownTimer = 240;
            
            if (currentGameMode === 'TUG') {
                const allPonies = [...ponies].sort(() => Math.random() - 0.5);
                const teamMap = {};
                allPonies.forEach((p, index) => {
                    p.team = (index % 2 === 0) ? 1 : -1; 
                    p.tapCount = 0; 
                    if (p.playerUUID) teamMap[p.playerUUID] = (p.team === 1) ? 'BLUE' : 'RED';
                });
                broadcast({ type: 'sync_ui', label: 'READY', mode: 'wait', teamMap: teamMap });
            } else {
                broadcast({ type: 'sync_ui', label: 'READY', mode: 'wait' });
            }

            ponies.forEach(p => {
                p.state = 'ready'; 
                p.manualSpeed = 0; p.tapCount = 0;
                p.isWalkAnimating = false; p.manualAnimTimer = 0; p.isTurbo = false; p.turboCharge = 0;
                p.z = 0; p.vz = 0; p.isStunned = false; p.stunTimer = 0; p.invincibleTimer = 0;
                p.pullOffset = 0;

                if (currentGameMode === 'TUG') {
                    const teamMembers = ponies.filter(tm => tm.team === p.team).sort((a,b) => a.id.localeCompare(b.id));
                    const myIndex = teamMembers.findIndex(tm => tm.id === p.id);
                    
                    const baseY = (GAME_H - PONY_SIZE) / 2 + 10; 

                    if (p.team === 1) {
                        p.x = (GAME_W / 2) - 100 - (myIndex * 50); 
                        p.facing = 1; 
                    } else {
                        p.x = (GAME_W / 2) + 100 + (myIndex * 50);
                        p.facing = -1;
                    }
                    p.y = baseY; 
                } else {
                    p.x = 20; 
                    p.facing = 1;
                    p.y = 30 + Math.random() * (GAME_H - PONY_SIZE - 30);
                }
            });

            document.getElementById('hud').style.display = 'none'; document.getElementById('queue-text').style.display = 'none';
            setBarVisibility(true); 
            
            let modeName = "CLASSIC";
            if (currentGameMode === 'RED_LIGHT') modeName = "STOP?";
            else if (currentGameMode === 'HURDLE') modeName = "JUMP";
            else if (currentGameMode === 'CLASSIC') modeName = "RUN";
            else if (currentGameMode === 'TUG') modeName = "TEAM";

            updateBarText(modeName, "#ffffff"); 
            
            const tugLayer = document.getElementById('tug-layer');
            if (currentGameMode === 'TUG' && tugLayer) {
                tugValue = 50;
                tugLayer.style.display = 'block';
                
                const bZone = document.getElementById('tug-blue-zone');
                if(bZone) bZone.style.width = '50%';
                const rZone = document.getElementById('tug-red-zone');
                if(rZone) rZone.style.width = '50%';
                
                const targetX = (window.innerWidth / 2) - (1700 * layout.scale); 
                layout.x = targetX;
                applyLayout(false);
            } else if (tugLayer) {
                document.getElementById('game-screen').className = ''; 
                lightState = 'GREEN'; 
                tugLayer.style.display = 'none';
            }
            
            obstacles = [];
        }

        function startRace() {
            updateBarText("GO!", "#ffffff");
            
            let statusText = "STATUS: RACING";
            let mobileInfo = "RUN (TAP)";
            
            const tugLayer = document.getElementById('tug-layer');
            if(tugLayer) tugLayer.style.display = 'none';

            if (currentGameMode === 'HURDLE') {
                statusText = "STATUS: JUMP";
                mobileInfo = "TAP: RUN / UP: JUMP"; 
                obstacles = [];
                for(let ox = 500; ox < FINISH_X - 200; ox += (400 + Math.random() * 300)) {
                    obstacles.push({ x: ox, width: 10, passed: false });
                }
            } else if (currentGameMode === 'RED_LIGHT') {
                statusText = "STATUS: STOP?"; 
                mobileInfo = "WATCH!"; 
                obstacles = []; 
                lightState = 'GREEN';
                redLightTimer = (120 + Math.random() * 100) * 0.8; 
                document.getElementById('game-screen').classList.add('bg-green');
                playSignalSound('GREEN');
            } else if (currentGameMode === 'TUG') {
                statusText = "TEAM BATTLE";
                mobileInfo = "PULL!";
                tugValue = 50; 
                obstacles = [];
                
                if(tugLayer) tugLayer.style.display = 'block';

                const teamMap = {};
                ponies.forEach(p => {
                    if (p.playerUUID) teamMap[p.playerUUID] = (p.team === 1) ? 'BLUE' : 'RED';
                });
                broadcast({ type: 'sync_ui', label: 'PULL!', mode: 'tug', teamMap: teamMap });
            } else {
                statusText = "STATUS: RUN";
                obstacles = [];
            }

            const hud = document.getElementById('hud'); hud.style.display = 'block'; hud.innerText = statusText;
            const vfdOverlay = document.getElementById('vfd-overlay');
            vfdOverlay.classList.remove('vfd-active'); void vfdOverlay.offsetWidth; vfdOverlay.classList.add('vfd-active');
            const textItems = document.querySelectorAll('.bar-text-item');
            textItems.forEach((item, index) => { item.style.animation = `text-vanish 0.05s linear forwards ${delay = 0.02 + (index * 0.06)}s`; });
            setTimeout(() => { if (gameState === 'RACING') { setBarVisibility(false); vfdOverlay.classList.remove('vfd-active'); } }, 1500);
            
            ponies.forEach(p => { 
                if (currentGameMode !== 'TUG') p.speed = 3.0 + Math.random() * 2.5; 
                p.state = 'racing'; 
                p.finishedWalking = false; 
                p.z = 0; p.vz = 0; p.isStunned = false; p.stunTimer = 0; p.invincibleTimer = 0;
                if(p.isManual) p.lastTapTime = Date.now(); 
            });
            
            if (currentGameMode !== 'TUG') {
                grass = []; gameState = 'RACING'; 
                broadcast({ type: 'sync_ui', label: 'RUN!', mode: 'mash', infoText: mobileInfo });
            } else {
                gameState = 'RACING';
            }
        }

        function gameLoop() { updateGameLogic(); draw(); requestAnimationFrame(gameLoop); }

        function updateGameLogic() {
            spawnSnow();
            const alert = document.getElementById('queue-text'); const hud = document.getElementById('hud');
            
            if (gameState === 'COOLDOWN' && currentGameMode === 'TUG') {
                ponies.forEach(p => { p.frame++; });
            }

            if (gameState === 'WAITING_TO_START') {
                waitTimer--; alert.style.display = 'block'; const sec = Math.ceil(waitTimer / 60); alert.innerText = `NEXT ROUND IN ${sec}`;
                if (sec > 0 && lastBroadcastText !== sec) { broadcast({ type: 'sync_ui', label: `STARTING ${sec}`, mode: 'wait' }); lastBroadcastText = sec; }
                updatePoniesMovement(); if (waitTimer <= 0) startCooldown();
            } else if (gameState === 'COOLDOWN') {
                cooldownTimer--; alert.style.display = 'none';
                if (cooldownTimer > 180) { } else {
                    const sec = Math.ceil(cooldownTimer / 60); updateBarText(sec.toString(), '#ffffff');
                    if (cooldownTimer % 60 === 59) triggerFlash();
                    if (sec > 0 && lastBroadcastText !== sec) { broadcast({ type: 'sync_ui', label: sec.toString(), mode: 'wait' }); lastBroadcastText = sec; }
                }
                if (cooldownTimer <= 0) startRace(); 
                if (currentGameMode !== 'TUG') updatePoniesMovement(); 
            } else if (gameState === 'RACING') {
                if (ponyQueue.length > 0) { alert.style.display = 'block'; alert.innerText = `${ponyQueue.length} WAITING NEXT ROUND`; } else { alert.style.display = 'none'; }
                
                if (currentGameMode === 'TUG') {
                    
                    ponies.forEach(p => {
                        if (!p.playerUUID && Math.random() < 0.015) { 
                            if (p.team === 1) tugValue = Math.min(100, tugValue + 1.0);
                            else tugValue = Math.max(0, tugValue - 1.0);
                            p.isWalkAnimating = true;
                            p.pullOffset = (p.team === 1 ? 10 : -10);
                        }
                    });

                    const bZone = document.getElementById('tug-blue-zone');
                    if(bZone) bZone.style.width = tugValue + '%';
                    const rZone = document.getElementById('tug-red-zone');
                    if(rZone) rZone.style.width = (100 - tugValue) + '%';

                    const targetX = (window.innerWidth / 2) - (1700 * layout.scale);
                    layout.x = targetX;
                    applyLayout(false);

                    const battleFront = GAME_W * (tugValue / 100);
                    
                    spawnBattleSparks(battleFront);

                    ponies.forEach(p => {
                        const teamMembers = ponies.filter(tm => tm.team === p.team).sort((a,b) => a.id.localeCompare(b.id));
                        const myIndex = teamMembers.findIndex(tm => tm.id === p.id);
                        
                        let basePositionX;
                        if (p.team === 1) {
                            basePositionX = battleFront - 80 - (myIndex * 45);
                        } else {
                            basePositionX = battleFront + 80 + (myIndex * 45);
                        }
                        
                        const desiredX = basePositionX + (p.pullOffset || 0);
                        
                        const smoothFactor = 0.15;
                        p.x = p.x + (desiredX - p.x) * smoothFactor;
                        
                        if (p.pullOffset) p.pullOffset *= 0.8;
                        if (Math.abs(p.pullOffset) < 1) p.pullOffset = 0;
                        
                        if (Math.abs(desiredX - p.x) < 1 && !p.isManual) {
                             p.isWalkAnimating = false;
                        } else {
                             p.isWalkAnimating = true;
                        }
                    });

                    if (tugValue >= 95) {
                        endTugWar(1); // Blue Wins
                    } else if (tugValue <= 5) {
                        endTugWar(-1); // Red Wins
                    }

                } else if (currentGameMode === 'RED_LIGHT') {
                    redLightTimer--;
                    if (redLightTimer <= 0) {
                        const screen = document.getElementById('game-screen');
                        screen.className = ''; 
                        if (lightState === 'GREEN') {
                            lightState = 'YELLOW';
                            redLightTimer = 30; 
                            screen.classList.add('bg-yellow');
                            updateBarText("STOP?", "#ffb300"); 
                            setBarVisibility(true);
                            playSignalSound('YELLOW');
                        } else if (lightState === 'YELLOW') {
                            lightState = 'RED';
                            redLightTimer = 60 + Math.random() * 90; 
                            screen.classList.add('bg-red');
                            updateBarText("STOP!", "#ff5252"); setBarVisibility(true);
                            playSignalSound('RED');
                        } else if (lightState === 'RED') {
                            lightState = 'GREEN';
                            redLightTimer = (100 + Math.random() * 150) * 0.8; 
                            screen.classList.add('bg-green');
                            updateBarText("GO!", "#69f0ae"); 
                            playSignalSound('GREEN');
                            setTimeout(() => { if (lightState === 'GREEN') setBarVisibility(false); }, 500);
                        }
                    }
                    updatePoniesMovement(); 
                    checkRaceEnd();
                } else {
                    updatePoniesMovement(); 
                    checkRaceEnd();
                }

            } else if (gameState === 'ROAMING') {
                hud.style.display = 'block'; hud.innerText = "NOWHERE TO RUN";
                document.getElementById('game-screen').className = ''; 
                if (ponyQueue.length > 0) { alert.style.display = 'block'; alert.innerText = `${ponyQueue.length} WAITING NEXT ROUND`; } else { alert.style.display = 'none'; }
                updatePoniesMovement();
            }
            
            const active = ponies.filter(p => p.state === 'racing');
            if (active.length === 0 && Math.random() < 0.2) {
                const segmentSize = 500; const totalSegments = Math.ceil(GAME_W / segmentSize);
                for(let i=0; i<totalSegments; i++) {
                    const startX = i * segmentSize; const endX = (i + 1) * segmentSize;
                    const count = grass.filter(g => g.x >= startX && g.x < endX).length;
                    if (count < 2 && Math.random() < 0.05) { grass.push({ x: startX + Math.random() * segmentSize, y: 20 + Math.random() * (GAME_H - 40) }); }
                }
            }
        }

        function endTugWar(winnerTeam) {
            gameState = 'FINISHED';
            const totalPlayers = ponies.length;
            const eliminationCount = Math.max(0, totalPlayers - 10);
            let losers = ponies.filter(p => p.team !== winnerTeam);
            losers.sort((a, b) => a.tapCount - b.tapCount);
            const toExplode = new Set(losers.slice(0, eliminationCount).map(p => p.id));
            let mvpPony = null;
            let maxTaps = -1;

            ponies.forEach(p => {
                p.hasCrown = false;
                p.isStreak = false;

                if (toExplode.has(p.id)) {
                    explode(p); 
                } else {
                    p.state = 'roaming'; 
                    p.targetX = null;
                    p.targetY = null;
                    p.timer = 0;
                    if (p.team === winnerTeam) {
                        if (p.tapCount > maxTaps) {
                            maxTaps = p.tapCount;
                            mvpPony = p;
                        }
                    }
                }
            });

            if (mvpPony) {
                mvpPony.hasCrown = true;
                mvpPony.isStreak = true;
            }
            
            const winnerText = "WIN"; 
            updateBarText(winnerText, "#fff");
            setBarVisibility(true);

            const tugLayer = document.getElementById('tug-layer');
            if(tugLayer) tugLayer.style.display = 'none';
            
            setTimeout(() => {
                if (ponyQueue.length > 0) {
                    gameState = 'WAITING_TO_START';
                    waitTimer = 180;
                } else {
                    gameState = 'ROAMING';
                    setBarVisibility(false);
                    layout.x = 0; applyLayout(false); 
                    broadcast({ type: 'sync_ui', label: 'DONE', mode: 'wait' });
                    
                    setTimeout(() => {
                        if (gameState === 'ROAMING') {
                             broadcast({ type: 'sync_ui', label: 'START RACE', mode: 'start' });
                        }
                    }, 2000);
                }
            }, 4000);
        }

        function checkRaceEnd() {
            const finished = ponies.filter(p => p.state === 'finished'); let raceOverTrigger = false;
            if (ponies.length > 10) { if (finished.length >= 10) raceOverTrigger = true; } else { if (ponies.length > 0 && finished.length === ponies.length) raceOverTrigger = true; }
            if (raceOverTrigger) {
                if (ponies.length > 10) {
                    const losers = ponies.filter(p => p.state === 'racing'); losers.forEach(p => explode(p));
                    ponies = ponies.filter(p => p.state === 'finished');
                }
                ponies.forEach(p => { p.state = 'roaming'; p.timer = 0; p.targetX = null; p.targetY = null; p.isWalkAnimating = false; p.isTurbo = false; p.turboCharge = 0; });
                if (ponyQueue.length > 0) { gameState = 'WAITING_TO_START'; waitTimer = 180; } else {
                    gameState = 'ROAMING'; broadcast({ type: 'sync_ui', label: 'DONE', mode: 'wait' });
                    setTimeout(() => { if (gameState === 'ROAMING') broadcast({ type: 'sync_ui', label: 'START RACE', mode: 'start' }); }, 3000);
                }
                document.getElementById('game-screen').className = '';
                setBarVisibility(false);
            }
        }

        function spawnTrail(p) {
            const fxLayer = document.getElementById('layer-fx');
            const count = Math.random() < 0.5 ? 1 : 2; 
            for (let i = 0; i < count; i++) {
                const el = document.createElement('div');
                el.className = 'trail-segment';
                el.style.left = (p.x - 20 + Math.random() * 10) + 'px';
                el.style.top = (p.y + 15 + Math.random() * 15) + 'px';
                el.style.background = p.color;
                el.style.boxShadow = `0 0 0px ${p.color}`;
                fxLayer.appendChild(el);
                setTimeout(() => el.remove(), 400);
            }
        }

        function spawnSnow() {
            const snowLayer = document.getElementById('layer-snow'); const count = Math.random() < 0.5 ? 1 : 2;
            for(let i=0; i<count; i++) {
                const el = document.createElement('div'); el.className = 'snowflake'; // CSS中已删除snowflake样式，因为是复古风格，这里可能不需要了，或者改为简单的白色方块
                // 复古风格不需要复杂的雪花，这里跳过
            }
        }

        function updatePoniesMovement() {
            let winnerFoundThisFrame = false; const finishedCount = ponies.filter(p => p.state === 'finished').length;
            ponies.forEach(p => {
                p.frame++; p.isWalkAnimating = false; p.isTurbo = false;
                if (p.manualAnimTimer > 0) p.manualAnimTimer--; p.turboCharge = Math.max(0, p.turboCharge - 1);
                
                if (p.invincibleTimer > 0) p.invincibleTimer--;

                if (p.state === 'ready') { 
                    if (currentGameMode !== 'TUG') p.x = 20; 
                    return; 
                }

                if (p.state === 'racing') {
                    if (p.isStunned) {
                        p.stunTimer--;
                        if (p.stunTimer <= 0) p.isStunned = false;
                        p.isWalkAnimating = false; 
                        if (p.manualSpeed < 0) { p.x += p.manualSpeed; p.manualSpeed *= 0.9; }
                    } else {
                        if (p.playerUUID) {
                            if (p.isManual) {
                                if (Date.now() - p.lastTapTime > 10000) { p.isManual = false; if (!p.name.includes("(BOT)")) p.name += " (BOT)"; }
                            }
                        }
                        if (p.isManual) {
                            p.manualSpeed *= 0.95; if (p.manualSpeed < 0.1) p.manualSpeed = 0;
                            p.x += p.manualSpeed; p.isWalkAnimating = p.manualSpeed > 0.1;
                        } else {
                            if (currentGameMode === 'RED_LIGHT' && lightState === 'RED') {
                                if (Math.random() < 0.02) p.x += 2; 
                            } else {
                                p.x += p.speed * (0.9 + Math.random() * 0.2); p.isWalkAnimating = true;
                                if (currentGameMode === 'HURDLE' && !p.isJumping) {
                                    const nearestObs = obstacles.find(o => o.x > p.x && o.x < p.x + 150); 
                                    if (nearestObs && Math.random() < 0.15) { 
                                        p.isJumping = true; p.vz = 12; 
                                    }
                                }
                            }
                        }

                        if (p.isJumping) {
                            p.z += p.vz;
                            p.vz -= 0.8; 
                            if (p.z <= 0) {
                                p.z = 0; p.vz = 0; p.isJumping = false;
                            }
                        }

                        if (p.invincibleTimer <= 0) {
                            if (currentGameMode === 'HURDLE') {
                                obstacles.forEach(obs => {
                                    if (p.x + 40 > obs.x && p.x < obs.x + obs.width) {
                                        if (p.z < 20) { 
                                            p.isStunned = true;
                                            p.stunTimer = 30; 
                                            p.invincibleTimer = 90; 
                                            p.manualSpeed = 0; 
                                            p.x = obs.x - 10; 
                                            triggerPonyEmoji(p.playerUUID, 'POOP'); 
                                        }
                                    }
                                });
                            }
                        }

                        if (p.turboCharge > 60 && Math.random() < 0.4) spawnTrail(p);
                        if (p.turboCharge > 30) p.isTurbo = true;
                        p.facing = 1;
                        if (p.x >= FINISH_X) {
                            if (p.state === 'racing') {
                                p.state = 'finished';
                                p.isTurbo = false;
                                if (p.playerUUID) {
                                    broadcast({ type: 'player_finished', uuid: p.playerUUID });
                                }
                                if (finishedCount === 0 && !winnerFoundThisFrame && gameState === 'RACING') {
                                    winnerFoundThisFrame = true; if (p.hasCrown) p.isStreak = true; else { p.hasCrown = true; p.isStreak = false; }
                                    ponies.forEach(o => { if(o.id !== p.id) { o.hasCrown = false; o.isStreak = false; }});
                                }
                            }
                        }
                    }
                } else if (p.state === 'finished') {
                    p.z = 0;
                    if (p.x < GAME_W - 50) { p.x += 0.8; p.finishedWalking = true; p.isWalkAnimating = true; }
                    else { p.finishedWalking = false; aiBehavior(p, true); }
                } else { p.finishedWalking = false; aiBehavior(p, false); }
                p.x = Math.max(0, Math.min(GAME_W - 38, p.x)); p.y = Math.max(p.hasCrown ? 35 : 20, Math.min(GAME_H - 44 - 6, p.y));
            });
        }

        function aiBehavior(p, restrictFinish) {
            const minX = restrictFinish ? FINISH_X : 0; const maxX = GAME_W - 38; const maxY = GAME_H - 44; const minY = p.hasCrown ? 35 : 20;
            if (p.state === 'roaming' || p.state === 'finished') {
                for(let i=0; i<grass.length; i++) {
                    const g = grass[i];
                    if (Math.abs(g.x - p.x) < 50 && Math.abs(g.y - p.y) < 50) { p.state = 'eating'; p.timer = 50; grass.splice(i, 1); p.targetX = null; p.targetY = null; return; }
                }
                if (p.timer-- <= 0) {
                    const action = Math.random();
                    if (action < 0.3) { p.targetX = (p.x < GAME_W / 2) ? GAME_W - 100 - Math.random() * 400 : 50 + Math.random() * 400; p.targetY = minY + Math.random() * (maxY - minY); p.timer = 400 + Math.random() * 400; p.roamSpeed = 2.0; }
                    else if (action < 0.8) { p.targetX = p.x + (Math.random() - 0.5) * 600; p.targetY = minY + Math.random() * (maxY - minY); p.timer = 100 + Math.random() * 200; p.roamSpeed = 0.8; }
                    else { p.targetX = null; p.targetY = null; p.timer = 60 + Math.random() * 120; p.roamSpeed = 0; }
                }
                if (p.targetX !== null && p.targetY !== null) {
                    const dx = p.targetX - p.x; const dy = p.targetY - p.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 5) { p.targetX = null; p.targetY = null; p.timer = 0; }
                    else { const speed = p.roamSpeed || 0.5; p.x += (dx / dist) * speed; p.y += (dy / dist) * speed; p.facing = Math.sign(dx) || 1; p.isWalkAnimating = true; }
                }
            } else if (p.state === 'eating') { if (p.timer-- <= 0) p.state = 'roaming'; }
        }

        function explode(p) {
            const fx = document.getElementById('layer-fx');
            for(let i=0; i<20; i++) {
                const el = document.createElement('div'); el.className = 'explosion';
                el.style.left = (p.x + 19) + 'px'; el.style.top = (p.y + 19) + 'px'; el.style.background = p.color; fx.appendChild(el);
                const angle = Math.random() * 6.28, spd = 3 + Math.random() * 5;
                let vx = Math.cos(angle) * spd, vy = Math.sin(angle) * spd, life = 40;
                const tick = () => { if (life-- <= 0) return el.remove(); el.style.left = (parseFloat(el.style.left) + vx) + 'px'; el.style.top = (parseFloat(el.style.top) + vy) + 'px'; el.style.opacity = life/40; requestAnimationFrame(tick); };
                tick();
            }
            const grassCount = Math.floor(Math.random() * 3) + 1; for(let i=0; i<grassCount; i++) { grass.push({ x: p.x + (Math.random()-0.5) * 60, y: p.y + (Math.random()-0.5) * 40 }); }
            
            ponies = ponies.filter(target => target.id !== p.id); 
            
            if (p.playerUUID) { broadcast({ type: 'eliminated', uuid: p.playerUUID }); }
        }

        function draw() {
            // 渲染障碍物和草地
            const grassL = document.getElementById('layer-grass'); 
            let htmlContent = grass.map(g => `<div class="grass" style="left:${g.x}px; top:${g.y}px"></div>`).join('');
            if (gameState === 'RACING' || gameState === 'COOLDOWN') {
                htmlContent += obstacles.map(o => `<div class="obstacle" style="left:${o.x}px; height:30px;"></div>`).join('');
            }
            grassL.innerHTML = htmlContent;

            const ponyL = document.getElementById('layer-pony'); const nodes = Array.from(ponyL.children); const ids = new Set(ponies.map(p => p.id));
            nodes.forEach(n => { if(!ids.has(n.id)) n.remove(); });
            ponies.forEach(p => {
                let el = document.getElementById(p.id);
                if (!el) {
                    el = document.createElement('div'); el.id = p.id; el.className = 'entity';
                    el.innerHTML = `<div class="aura"></div><div class="crown-container" style="display: none;"><svg width="18" height="18" viewBox="0 0 24 24" fill="#ffffff" stroke="#000" stroke-width="2"><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"></path></svg></div><div class="name-tag">${p.name}</div><div class="p-grid" style="display:grid; grid-template-columns:repeat(11,1fr); width:100%; height:100%;"></div>`;
                    ponyL.appendChild(el);
                }
                
                el.style.transform = `translate(${p.x}px, ${p.y - p.z}px) scale(1.1)`; 
                el.style.zIndex = Math.floor(p.y);
                
                if (p.isStunned) {
                    el.style.filter = "grayscale(100%) opacity(0.5)";
                } else if (p.invincibleTimer > 0) {
                    el.style.filter = (Math.floor(p.invincibleTimer / 5) % 2 === 0) ? "opacity(0.3)" : "opacity(0.8)";
                } else {
                    el.style.filter = "none";
                }

                const crownC = el.querySelector('.crown-container'); if (p.hasCrown) { crownC.style.display = 'flex'; } else { crownC.style.display = 'none'; }
                el.querySelector('.aura').style.display = p.isStreak ? 'block' : 'none'; el.querySelector('.name-tag').style.color = p.hasCrown ? '#fff' : '#fff';
                const gridEl = el.querySelector('.p-grid');
                if (p.isTurbo) { gridEl.classList.add('trail-active'); gridEl.style.setProperty('--trail-c', p.color); } else { gridEl.classList.remove('trail-active'); gridEl.style.removeProperty('--trail-c'); }
                let frameStep = 0; if (p.isManual && p.state === 'racing') { frameStep = (p.manualAnimTimer > 0) ? 1 : 0; } else if (p.isWalkAnimating) { frameStep = Math.floor(p.frame / 5) % 2; }
                gridEl.style.transform = `scaleX(${p.facing || 1})`;
                let html = '';
                for(let y=0; y<11; y++) {
                    let row = p.pixels[y];
                    if (p.state === 'eating') { if (y <= 5) { row = (y >= 2) ? p.pixels[y - 2] : [0,0,0,0,0,0,0,0,0,0,0]; } }
                    else if (frameStep === 1 && y > 8) { row = [row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[0]]; }
                    for(let x=0; x<11; x++) { if (row[x]) html += `<div style="background:${p.color}; width:100%; height:100%; grid-column:${x+1}; grid-row:${y+1}; box-shadow:1px 1px 0 #000;"></div>`; }
                }
                gridEl.innerHTML = html;
            });
        }

        function initMobile() {
            playerUUID = localStorage.getItem('horse_uuid'); if (!playerUUID) { playerUUID = 'user_' + Math.random().toString(36).substr(2, 9); localStorage.setItem('horse_uuid', playerUUID); }
            initEditor('m-grid', 'm-colors', mobileGrid);
            try {
                peer = new Peer(null, PEER_CONFIG);
                peer.on('open', () => {
                    conn = peer.connect(new URLSearchParams(window.location.search).get('host'));
                    conn.on('open', () => { document.getElementById('m-status').innerText = "CONNECTED"; document.getElementById('m-status').style.color = "#fff"; conn.send({ type: 'check_reconnect', uuid: playerUUID }); });
                    conn.on('data', data => {
                        if (data.type === 'reconnect_success') { document.getElementById('m-editor-ui').style.display = 'none'; document.getElementById('m-controller').style.display = 'flex'; }
                        else if (data.type === 'sync_ui') {
                            if (mobileBtnState === 'dead') return;

                            const btn = document.getElementById('m-btn'); 
                            const info = document.getElementById('m-info'); 
                            const modeWrapper = document.getElementById('m-mode-wrapper');
                            
                            mobileBtnState = data.mode; 
                            btn.className = 'push-btn'; 

                            modeWrapper.style.display = 'none';

                            if (data.mode === 'tug') {
                                btn.classList.add('btn-mash');
                                btn.innerText = "PULL!";
                                
                                if (data.teamMap && data.teamMap[playerUUID]) {
                                    const myTeam = data.teamMap[playerUUID];
                                    info.innerText = `TEAM ${myTeam}`;
                                    info.style.color = "#fff"; // 统一白色
                                    btn.classList.add(myTeam === 'RED' ? 'btn-team-red' : 'btn-team-blue');
                                } else {
                                    info.innerText = "SPECTATING"; 
                                }
                            }
                            else if (data.mode === 'wait') { 
                                btn.classList.add('btn-wait'); btn.innerText = data.label; info.innerText = "GET READY..."; 
                                info.style.color = "#888"; 
                            }
                            else if (data.mode === 'mash') { 
                                btn.classList.add('btn-mash'); 
                                btn.innerText = "RUN"; 
                                info.innerText = data.infoText || "TAP TO RUN"; 
                                randomizeMusic();
                            }
                            else if (data.mode === 'start') { 
                                btn.classList.add('btn-start'); btn.innerText = data.label; info.innerText = "RACE FINISHED"; 
                                modeWrapper.style.display = 'flex';
                            }
                        } else if (data.type === 'eliminated' && data.uuid === playerUUID) {
                            const btn = document.getElementById('m-btn'); const info = document.getElementById('m-info'); 
                            mobileBtnState = 'dead'; 
                            btn.className = 'push-btn btn-dead'; 
                            btn.innerText = "CREATE\nAGAIN"; 
                            info.innerText = "ELIMINATED";
                            document.getElementById('m-mode-wrapper').style.display = 'none';
                            vibrate([100, 50, 100]); 
                        } else if (data.type === 'player_finished' && data.uuid === playerUUID) {
                            mobileBtnState = 'finished';
                            const btn = document.getElementById('m-btn');
                            btn.className = 'push-btn btn-wait';
                            btn.innerText = "DONE";
                            document.getElementById('m-info').innerText = "WAITING...";
                            document.getElementById('m-mode-wrapper').style.display = 'none';
                            vibrate([200]); 
                        }
                    });
                });
            } catch(e) { console.error(e); }
        }

        function handleMotion(event) {
            const acc = event.acceleration; 
            if (!acc) return;
            const magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
            if (magnitude > 15) {
                const now = Date.now();
                if (now - lastShakeTime > 500) { 
                    lastShakeTime = now;
                    if(conn) conn.send({ type: 'jump', uuid: playerUUID }); 
                    vibrate(200); 
                }
            }
        }

        const mBtn = document.getElementById('m-btn');
        let touchStartY = 0;
        let touchStartTime = 0;

        mBtn.addEventListener('touchstart', (e) => {
            if (mobileBtnState === 'dead') { resetMobile(); return; }
            if (mobileBtnState === 'finished') return;
            if (mobileBtnState === 'start') { 
                const selectedMode = document.getElementById('m-mode-select').value;
                if(conn) conn.send({ type: 'force_start', mode: selectedMode }); 
                vibrate(50);
                return; 
            }
            if (mobileBtnState !== 'mash' && mobileBtnState !== 'tug') return;

            e.preventDefault(); 
            touchStartY = e.changedTouches[0].clientY;
            touchStartTime = Date.now();
            mBtn.style.transform = 'scale(0.95)'; 
        }, {passive: false});

        mBtn.addEventListener('touchend', (e) => {
            if (mobileBtnState !== 'mash' && mobileBtnState !== 'tug') return;
            e.preventDefault();
            mBtn.style.transform = 'scale(1)'; 

            const touchEndY = e.changedTouches[0].clientY;
            const diffY = touchStartY - touchEndY; 
            const timeDiff = Date.now() - touchStartTime;

            if (diffY > 50) {
                if(conn) conn.send({ type: 'jump', uuid: playerUUID });
                vibrate(100); 
            } else {
                if(conn) conn.send({ type: 'tap', uuid: playerUUID });
                initAudio(); playNextNote();
                vibrate(15); 
            }
        });

        function sendMobile() {
            if(!conn) return alert("Not Connected!");
            const nameInput = document.getElementById('m-name'); let name = nameInput.value.trim().replace(/[^a-zA-Z0-9]/g, ''); if (!name) name = "PLAYER"; name = name.toUpperCase();
            let hasPixels = false; for(let r=0; r<11; r++) { for(let c=0; c<11; c++) { if (mobileGrid[r][c] === 1) { hasPixels = true; break; } } if(hasPixels) break; }
            if (!hasPixels) { alert("CANVAS IS EMPTY"); return; }
            
            initAudio(); randomizeMusic();

            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotion);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }

            conn.send({ type: 'spawn', payload: { name: name, pixels: mobileGrid, color: selectedColor, uuid: playerUUID } });
            document.getElementById('m-editor-ui').style.display = 'none'; document.getElementById('m-controller').style.display = 'flex';
        }

        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }

        function triggerPonyEmoji(uuid, emojiType) {
            const pony = ponies.find(p => p.playerUUID === uuid); if (!pony) return;
            const pEl = document.getElementById(pony.id); if (!pEl) return;
            
            let container;
            if (emojiType === 'FACE') {
                container = document.createElement('div');
                container.className = 'pop-text';
                container.innerText = "?";
                container.style.color = '#fff'; // 强制白色
            } else {
                container = document.createElement('div');
                container.className = 'pixel-emoji-container';
                container.appendChild(createPixelIcon(emojiType, 2, '#fff'));
            }

            pEl.appendChild(container);
            if (audioCtx && audioCtx.state === 'running') {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(800, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1); gain.gain.setValueAtTime(0.05, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            }
            setTimeout(() => container.remove(), 2500);
        }

        function sendEmoji(type) {
            if(!conn) return; conn.send({ type: 'emoji', uuid: playerUUID, content: type });
            const btn = event.currentTarget; btn.style.transform = 'scale(0.8)'; setTimeout(() => btn.style.transform = 'scale(1)', 100);
            vibrate(10); 
        }

        function resetMobile() { 
            document.getElementById('m-controller').style.display = 'none'; 
            document.getElementById('m-editor-ui').style.display = 'block'; 
            renderGrid('m-grid', mobileGrid, selectedColor); 
            mobileBtnState = 'wait'; 
        }
        function clearMobile() { clearGridData(mobileGrid); renderGrid('m-grid', mobileGrid, selectedColor); }
        function clearDesktop() { clearGridData(pcGrid); renderGrid('pc-grid', pcGrid, selectedColor); }
        function clearGridData(grid) { for(let r=0; r<11; r++) for(let c=0; c<11; c++) grid[r][c] = 0; }
        function restoreGridData(grid) { for(let r=0; r<11; r++) for(let c=0; c<11; c++) grid[r][c] = DEFAULT_PIXELS[r][c]; }
        function openDesktopEditor() { renderGrid('pc-grid', pcGrid, selectedColor); document.getElementById('modal-editor').style.display = 'flex'; }
        function savePCPony() { let name = document.getElementById('pc-name').value.trim().replace(/[^a-zA-Z0-9]/g, ''); if (!name) name = "PLAYER"; name = name.toUpperCase(); requestSpawnPony(name, pcGrid, selectedColor); document.getElementById('modal-editor').style.display = 'none'; }

        function initEditor(gridId, colorId, dataGrid) {
            const gridEl = document.getElementById(gridId); const colorEl = document.getElementById(colorId); colorEl.innerHTML = '';
            Object.values(COLORS).forEach(c => { const dot = document.createElement('div'); dot.className = `c-dot ${c === selectedColor ? 'active' : ''}`; dot.style.background = c; dot.onclick = () => { selectedColor = c; renderGrid(gridId, dataGrid, selectedColor); Array.from(colorEl.children).forEach(d => d.classList.remove('active')); dot.classList.add('active'); }; colorEl.appendChild(dot); });
            renderGrid(gridId, dataGrid, selectedColor);
            let drawing = false, eraseMode = false;
            const getCellCoords = (e) => { const t = e.touches ? e.touches[0] : e; const el = document.elementFromPoint(t.clientX, t.clientY); if (el && el.classList.contains('editor-cell')) { return { r: parseInt(el.dataset.r), c: parseInt(el.dataset.c), el: el }; } return null; };
            const startDraw = (e) => { if(e.cancelable) e.preventDefault(); drawing = true; const cell = getCellCoords(e); if (cell) { eraseMode = dataGrid[cell.r][cell.c] === 1; updateCell(cell.r, cell.c, cell.el); } };
            const moveDraw = (e) => { if (!drawing) return; if(e.cancelable) e.preventDefault(); const cell = getCellCoords(e); if (cell) { updateCell(cell.r, cell.c, cell.el); } };
            const endDraw = () => { drawing = false; };
            const updateCell = (r, c, el) => { const targetVal = eraseMode ? 0 : 1; if (dataGrid[r][c] !== targetVal) { dataGrid[r][c] = targetVal; if (targetVal === 1) { el.style.background = selectedColor; el.style.boxShadow = `0 0 5px ${selectedColor}`; } else { el.style.background = '#000'; el.style.boxShadow = 'none'; } } };
            gridEl.onmousedown = gridEl.ontouchstart = startDraw; window.onmousemove = window.ontouchmove = moveDraw; window.onmouseup = window.ontouchend = endDraw;
        }

        function renderGrid(id, data, color) {
            const el = document.getElementById(id); el.innerHTML = '';
            data.forEach((row, r) => row.forEach((val, c) => { const cell = document.createElement('div'); cell.className = 'editor-cell'; cell.dataset.r = r; cell.dataset.c = c; if(val) { cell.style.background = color; cell.style.boxShadow = `0 0 5px ${color}`; } else { cell.style.background = '#000'; } el.appendChild(cell); }));
        }
    </script>
</body>
</html>
